local scriptStatus = loadstring(game:HttpGet("https://pastebin.com/raw/tETBwUZF"))()
if not scriptStatus then return end

--local whitelistedUsers = loadstring(game:HttpGet("https://pastebin.com/raw/Em1Ae4Rx"))()
--if not table.find(whitelistedUsers, game.Players.LocalPlayer.Name) then return end

if not game:IsLoaded() then game.Loaded:Wait() end 

local config = {
    autoBlowBubble = false,
    autoSellBubble = false,
    sellBubbleCooldown = 10,
    collectDrops = false,
    oldPickupRange = nil,
    equipBest = false,
    selectedHatchEgg = "",
    autoHatch = false,
    hatchAnimation = nil,
    hatchAnimationState = false,
    selectedEnchantPets = {},
    selectedEnchants = {},
    autoEnchant = false,
    selectedGums = {},
    autoBuyGums = false,
    selectedFlavors = {},
    autoBuyFlavors = false,
    selectedShopItems = {},
    selectedRerollShops = {},
    autoBuyShopItems = false,
    selectedCraftPotions = {},
    autoCraftPotions = false,
    selectedConsumePotions = {},
    autoConsumePotions = false,
    selectedUpgradeMasteries = {},
    autoUpgradeMastery = false,
    autoClaimPlaytime = false,
    autoDoggyJump = false,
    autoClaimWheelSpin = false,
    autoSpinWheel = false,
    autoOpenMysteryBox = false,
    selectedRifts = {},
    selectedRiftLuck = "5",
    selectedRiftPotions = {},
    selectedRiftWebhook = "",
    autoRifts = false,
    selectedWebhookPetRarities = {},
    selectedWebhookPets = {},
    selectedWebhook = "",
    hatchingWebhookPingAll = false,
    hatchingWebhook = false,
    autoOpenChest = false,
    selectedIgnoreQuest = {},
    autoCompetitive = false,
    autoClawMachine = false,
    useSuperTicket = false,
    selectedDifficulty = "Insane",
    robotClawDrops = {},
    sendRobotClawWebhook = false,
}

local lp = game:GetService("Players").LocalPlayer
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local afkScript = lp:WaitForChild("PlayerScripts", 9e9):WaitForChild("AFK", 9e9)
local introGui = lp.PlayerGui:FindFirstChild("Intro")
local Network = require(ReplicatedStorage.Shared.Framework.Network.Remote)
local localData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local statsUtil = require(ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local eggsModule = require(ReplicatedStorage.Shared.Data.Eggs)
local hatchingModule = require(ReplicatedStorage.Client.Effects.HatchEgg)
local petsModule = require(ReplicatedStorage.Shared.Data.Pets)
local enchantsModule = require(ReplicatedStorage.Shared.Data.Enchants)
local gumsModule = require(ReplicatedStorage.Shared.Data.Gum)
local flavorsModule = require(ReplicatedStorage.Shared.Data.Flavors)
local codesModule = require(ReplicatedStorage.Shared.Data.Codes)
local shopsModule = require(ReplicatedStorage.Shared.Data.Shops)
local shopsUtil = require(ReplicatedStorage.Shared.Utils.ShopUtil)
local potionsModule = require(ReplicatedStorage.Shared.Data.Potions)
local masteryModule = require(ReplicatedStorage.Shared.Data.Mastery)
local doggyJumpUtil = require(ReplicatedStorage.Shared.Utils.DoggyJumpUtil)
local timeModule = require(ReplicatedStorage.Shared.Framework.Utilities.Math.Time)
local giftModule = require(ReplicatedStorage.Client.Effects.PhysicalItem.Gift)
local riftsModule = require(ReplicatedStorage.Shared.Data.Rifts)
local chestsModule = require(ReplicatedStorage.Shared.Data.Chests)
local questsUtil = require(ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local worldUtil = require(ReplicatedStorage.Shared.Utils.WorldUtil)
local minigameModule = require(ReplicatedStorage.Shared.Data.Minigames)
local powerItemsModule = require(ReplicatedStorage.Shared.Data.Powerups)

local function populateTable(moduleSrc, tbl)
    for i,v in pairs(moduleSrc) do
        table.insert(tbl, i)
    end
    table.sort(tbl)
end

local eggs = {"Infinity Egg"}
local eggsData = {}
local pets = {}
local enchants =  {}
local gums = {}
local flavors = {}
local gumNames = {}
local flavorNames = {}
local codes = {}
local shopsData = {"Buy All Items"}
local shopsName = {}
local potionsData = {"Craft All Potions"}
local potions = {}
local masteries = {}
local rifts = {}
local riftName = {}
local petsRarity = {}
local petsData = {}
local riftPotions = {}
local chests = {}
local craftCosts = {}
local clawDrops = {}
local powerIcons = {}
local petAssets = {}

populateTable(eggsModule, eggs)
populateTable(petsModule, pets)
populateTable(codesModule, codes)
populateTable(chestsModule, chests)

for i,v in pairs(enchantsModule) do
    for ii,vv in pairs(v) do
        local levels = v.Levels
        if levels then
            for iii = 1,levels do
                table.insert(enchants, tostring(i.."-"..iii))
            end
        end
        break
    end
end

for i,v in pairs(gumsModule) do
    if i ~= "Infinity Gum" and i ~= "VIP Gum" then
        gums[i] = {
            Cost = v.Cost.Amount
        }
    end
end

for i, _ in pairs(gums) do
    table.insert(gumNames, i)
end

for i,v in pairs(flavorsModule) do
    if i ~= "VIP Flavor" then
        flavors[i] = {
            Cost = v.Cost.Amount
        }
    end
end

for i, _ in pairs(flavors) do
    table.insert(flavorNames, i)
end

for i, v in pairs(shopsModule) do
    for ii, vv in pairs(v.RandomItems) do
        local product = vv.Product
        if not i == "TempShop" or not (v.DisplayName and v.DisplayName:find("Temp Shop")) then
            if typeof(product) == "table" then
                local formatted = string.format(
                    "%s | %s (%s%s)",
                    v.DisplayName,
                    product.Name,
                    product.Type,
                    product.Level and (" LVL " .. product.Level) or ""
                )
                table.insert(shopsData, formatted)
            end
        end
    end
end

for i, v in pairs(shopsModule) do
    for ii, vv in pairs(v.PermanentItems) do
        local product = vv.Product
        if not i == "TempShop" or not (v.DisplayName and v.DisplayName:find("Temp Shop")) then
            if typeof(product) == "table" then
                local formatted = string.format(
                    "%s | %s (%s%s)",
                    v.DisplayName,
                    product.Name,
                    product.Type,
                    product.Level and (" LVL " .. product.Level) or ""
                )
                table.insert(shopsData, formatted)
            end
        end
    end
end

for i,v in pairs(shopsModule) do
    if not v.DisplayName:find("Temp Shop") then
        table.insert(shopsName, v.DisplayName)
    end
end

for i, v in pairs(potionsModule) do
    if v.CraftingCosts and i ~= "Infinity Elixir" then
        for level = 2, #v.CraftingCosts+1 do
            table.insert(potionsData, i .. " " .. level)
        end
    end
end

for i, v in pairs(potionsModule) do
    if v.CraftingCosts then
        for level = 1, #v.CraftingCosts+2 do
            table.insert(potions, i .. " " .. level)
        end
    else
        table.insert(potions, i .. " " .. "1")
    end
end

for i,v in pairs(potionsModule) do
    if v.CraftingCosts then
        for level = 6, #v.CraftingCosts+2 do
            table.insert(riftPotions, i .. " " .. level)
        end
    else
        table.insert(riftPotions, i .. " " .. "1")
    end
end

for i,v in pairs(masteryModule.Upgrades) do
    table.insert(masteries, i)
end

for i,v in pairs(riftsModule) do
    if not i:find("gift") then
        if v.Egg then
            table.insert(rifts, i.." | "..v.Egg)
        else
            table.insert(rifts, i)
        end
    end
end

for i,v in pairs(riftsModule) do
    riftName[i] = v.Egg
end

for i, v in pairs(petsModule) do
    if not table.find(petsRarity, v.Rarity) then
        table.insert(petsRarity, v.Rarity)
    end
end

for i, v in pairs(petsModule) do
    local images = v.Images or {}

    petsData[i] = {
        Normal = (images.Normal and images.Normal:gsub("rbxassetid://", "")) or nil,
        Shiny = (images.Shiny and images.Shiny:gsub("rbxassetid://", "")) or nil,
        Mythic = (images.Mythic and images.Mythic:gsub("rbxassetid://", "")) or nil,
        MythicShiny = (images.MythicShiny and images.MythicShiny:gsub("rbxassetid://", "")) or nil,
        Rarity = v.Rarity,
        Chance = v.Chance
    }
end

for i, v in pairs(eggsModule) do
    if v.Island then
        eggsData[i] = {
            Island = v.Island,
            World = v.World
        }
    elseif v.World then
        eggsData[i] = {
            Island = v.World
        }
    end
end

for i, v in pairs(potionsModule) do
    if v.CraftingCosts then
        craftCosts[i] = {} 
        for ii, vv in pairs(v.CraftingCosts) do
            craftCosts[i][ii] = {
                PotionCost = vv.Potions,
                GemCost = vv.Gems
            }
        end
    end
end

for i,v in pairs(minigameModule["Robot Claw"].Rewards) do
    if v.Item.Name and v.Item.Level then
        table.insert(clawDrops, v.Item.Name.." | "..v.Item.Level)
    elseif v.Item.Name and not v.Item.Level then
        table.insert(clawDrops, v.Item.Name)
    end
end

for i,v in pairs(powerItemsModule) do
	powerIcons[v.Icon] = i
end

if introGui and introGui.Enabled then
    local loadingLabel = lp.PlayerGui.Intro.Logo.Bar.Label
    while task.wait() do
        if loadingLabel.Text == "100%" then
            break
        end
    end
    local playButton = lp.PlayerGui.Intro.Play.Button
    local lowGraphicsButton = lp.PlayerGui.Intro.Graphics.Content.Low.Action.Button

    if playButton and lowGraphicsButton and playButton.Visible and lowGraphicsButton.Visible then
        task.wait(2)
        firesignal(playButton["Activated"])
        firesignal(lowGraphicsButton["Activated"])
        task.wait(3)
    end
end

for i, v in pairs(getgc()) do
    if typeof(v) == "function" and getfenv(v).script == afkScript then
        local info = debug.getinfo(v)
        if info.name:find("onIdled") then
            hookfunction(v, function(...)
                return
            end)
        end
    end
end

for i, v in pairs(petsModule) do
    local images = v.Images or {}

    for ii, vv in pairs(images) do
        if vv then
            petAssets[vv] = ii .. " " .. tostring(i)
        end
    end
end

for i,v in pairs(getconnections(lp.Idled)) do v:Disable() end

local Fluent = loadstring(game:HttpGet("https://pastebin.com/raw/ivKf0LFW"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local Window = Fluent:CreateWindow({
    Title = "BGSI v1 - ja5on7190",
    TabWidth = 160,
    Size = UDim2.fromOffset(500, 425),
    Acrylic = false,
    Theme = "Obsidian Glow",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Mobile = Window:AddTab({ Title = "Mobile", Icon = "rbxassetid://10734921524" }),
    Farming = Window:AddTab({ Title = "Farming", Icon = "rbxassetid://10709811110" }),
    Pets = Window:AddTab({ Title = "Pets", Icon = "rbxassetid://10723345518" }),
    Autos = Window:AddTab({ Title = "Autos", Icon = "rbxassetid://10709782230" }),
    Rifts = Window:AddTab({ Title = "Rifts", Icon = "rbxassetid://10723417608" }),
    Competitive = Window:AddTab({ Title = "Competitive", Icon = "rbxassetid://10734962068" }),
    Minigames = Window:AddTab({ Title = "Minigames", Icon = "rbxassetid://10723416527" }),
    Webhooks = Window:AddTab({ Title = "Webhooks", Icon = "rbxassetid://10747366606" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://10709797985" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://10709810948" })
}

InterfaceManager:SetLibrary(Fluent)
SaveManager:SetLibrary(Fluent)

Window:SelectTab(1)

for i,v in pairs(CoreGui:GetDescendants()) do
    if v:IsA("TextLabel") and v.Text:find("BGSI") and v.Parent.Parent.Parent.Parent:IsA("ScreenGui") and v.Parent.Parent.Parent.Parent.Name == "ScreenGui" then
        v.Parent.Parent.Parent.Parent:SetAttribute("Animations", true)
    end
end

Tabs.Mobile:AddButton({
    Title = "Mobile Helper",
    Callback = function()    
        for i,v in pairs(CoreGui:GetDescendants()) do
            if v.Name == "Lebutton" then
                return
            end
        end
        local gui = Instance.new("ScreenGui")
        gui.Parent = CoreGui
        local button = Instance.new("TextButton")
        button.Text = "Hide/Show"
        button.Name = "Lebutton"
        button.BackgroundColor3 = Color3.new(1, 1, 1)
        button.Size = UDim2.new(0, 75, 0, 75)
        button.Position = UDim2.new(0.5, -button.Size.X.Offset / 2, 0, -50)
        button.Transparency = 0
        button.Parent = gui

        local uicorner = Instance.new("UICorner")
        uicorner.CornerRadius = UDim.new(0, 100)
        uicorner.Parent = button

        button.TextSize = 10
        button.TextColor3 = Color3.new(0, 0, 0)

        local function ToggleVisibility()
            for _, v in pairs(CoreGui:GetDescendants()) do
                if v:IsA("Frame") and v.Size.X.Offset == 500 and v.Size.Y.Offset == 425 and v.Parent:IsA("ScreenGui") then
                    v.Visible = not v.Visible
                end
            end
        end
            
        if UserInputService.TouchEnabled then
            button.Activated:Connect(ToggleVisibility)
        else
            button.MouseButton1Click:Connect(ToggleVisibility)
        end
    end
})

local blowBubbleToggle = Tabs.Farming:AddToggle("Blow Bubble Toggle", 
{
    Title = "Auto Blow Bubble", 
    Default = false,
    Callback = function(v)
        config.autoBlowBubble = v
        if v then
            spawn(blowBubble)
        end
    end 
})

local sellBubbleToggle = Tabs.Farming:AddToggle("Sell Bubble Toggle", 
{
    Title = "Auto Sell Bubble", 
    Description = "Configurations below.",
    Default = false,
    Callback = function(v)
        config.autoSellBubble = v
        if v then
            spawn(sellBubble)
        end
    end 
})

if config.oldPickupRange == nil then
    config.oldPickupRange = statsUtil.GetPickupRange
end

local collectDropsToggle = Tabs.Farming:AddToggle("Collect Drops Toggle", 
{
    Title = "Collect Drops", 
    Description = "Will collect coins and gems.",
    Default = false,
    Callback = function(v)
        config.collectDrops = v
        if v then
            statsUtil.GetPickupRange = function()
                return 1/0
            end
        else
            statsUtil.GetPickupRange = config.oldPickupRange
        end
    end 
})

task.spawn(function()
    while true do
        if config.collectDrops then
            local coin = findClosestCoin()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Pickups"):WaitForChild("CollectPickup"):FireServer(coin)            
        end
        task.wait(0.5)
    end
end)

local equipBestToggle = Tabs.Farming:AddToggle("Equip Best Toggle", 
{
    Title = "Auto Equip Best", 
    Default = false,
    Callback = function(v)
        config.equipBest = v
        if v then
            spawn(equipBestPet)
        end
    end 
})

local farmSettingsSection = Tabs.Farming:AddSection("Autofarm Settings")

local sellBubbleCooldownInput = Tabs.Farming:AddInput("Sell Bubble Cooldown Input", {
    Title = "Sell Bubble Cooldown (sec)",
    Description = "This determines how \noften it sells the bubble.",
    Numeric = true,
    Finished = false,
    Callback = function(cd)
        config.sellBubbleCooldown = cd
    end
})

local eggsDropdown = Tabs.Pets:AddDropdown("Eggs Dropdown", {
    Title = "Eggs",
    Description = "Select egg to hatch.",
    Values = eggs,
    Multi = false,
    Default = "",
})

eggsDropdown:OnChanged(function(egg)
    config.selectedHatchEgg = egg
end)

local hatchingToggle = Tabs.Pets:AddToggle("Hatching Toggle", 
{
    Title = "Auto Hatch", 
    Default = false,
    Callback = function(v)
        config.autoHatch = v
        if v then
            task.wait(1)
            spawn(hatchEgg)
        end
    end 
})

if not config.hatchAnimation then
    config.hatchAnimation = hatchingModule.Play
end

local hatchingAnimationToggle = Tabs.Pets:AddToggle("Hatching Animation Toggle", 
{
    Title = "Hatching Animation", 
    Default = true,
    Callback = function(v)
        config.hatchAnimationState = v
        if v then
            hatchingModule.Play = config.hatchAnimation
        elseif not v and config.hatchingWebhook then
            do end
        else
            hatchingModule.Play = function() return end
        end
    end 
})

task.spawn(function()
    while true do
        if not config.hatchAnimationState and config.hatchingWebhook then
            hatchingAnimationToggle:SetValue(true)
            Fluent:Notify({
                Title = "Hatching Animation",
                Content = "Automatically enabled hatch animation, disabling it will break hatch webhook.",
                Duration = 10
            })
        end
        task.wait()
    end
end)

local enchantingSection = Tabs.Autos:AddSection("Enchanting")

local function updatePets()
    local plrData = localData.Get()

    local equippedPets = {}
    local petInfo = {}
    local formattedInfo = {}

    for i, v in pairs(plrData.Teams) do
        for ii, vv in pairs(v.Pets) do
            table.insert(equippedPets, vv)
        end
    end

    for i, v in pairs(plrData.Pets) do
        if table.find(equippedPets, v.Id) and v.Name then
            local prefix = ""
            if v.MythicShiny then
                prefix = "Mythic Shiny "
            elseif v.Mythic then
                prefix = "Mythic "
            elseif v.Shiny then
                prefix = "Shiny "
            end

            local name = prefix .. v.Name

            if v.Enchants and #v.Enchants > 0 then
                local enchants = {}
                for ii, vv in pairs(v.Enchants) do
                    table.insert(enchants, vv.Id .. "-" .. vv.Level)
                end
                petInfo[v.Id] = {
                    Name = name,
                    Enchants = enchants
                }
            else
                petInfo[v.Id] = {
                    Name = name,
                    Enchants = {}
                }
            end
        end
    end

    for i, v in pairs(petInfo) do
        local enchantStr = "[" .. table.concat(v.Enchants, ", ") .. "]"
        local formattedStr = v.Name .. " " .. enchantStr .. " | " .. i
        table.insert(formattedInfo, formattedStr)
    end

    return formattedInfo
end

local petsMultiDropdown = Tabs.Autos:AddDropdown("Pets MultiDropdown", {
    Title = "Pets",
    Description = "Select the pets to enchant.",
    Values = updatePets(),
    Multi = true,
    Default = {},
})

petsMultiDropdown:OnChanged(function(pet)
    config.selectedEnchantPets = {}
    for petStr, State in next, pet do
        if State then
            local id = string.match(petStr, "|%s*(%S+)$")
            if id then
                table.insert(config.selectedEnchantPets, id)
            end
        end
    end
end)

Tabs.Autos:AddButton({
    Title = "Refresh Pets",
    Callback = function()
        local pets = updatePets()

        if pets then
            petsMultiDropdown:SetValues(pets)
        end
    end
})

local enchantsMultiDropdown = Tabs.Autos:AddDropdown("Enchants MultiDropdown", {
    Title = "Enchants",
    Description = "Select which enchants you want.",
    Values = enchants,
    Multi = true,
    Default = {},
})

enchantsMultiDropdown:OnChanged(function(enchant)
    config.selectedEnchants = {}
    for enchant, State in next, enchant do
        table.insert(config.selectedEnchants, enchant)
    end
end)

local enchantingToggle = Tabs.Autos:AddToggle("Enchanting Toggle", 
{
    Title = "Auto Enchant", 
    Default = false,
    Callback = function(v)
        config.autoEnchant = v
        if v then
            spawn(Enchant)
        end
    end 
})

local purchasingSection = Tabs.Autos:AddSection("Purchasing")

local gumsMultiDropdown = Tabs.Autos:AddDropdown("Gums MultiDropdown", {
    Title = "Gums",
    Description = "Select gums to auto purchase.",
    Values = gumNames,
    Multi = true,
    Default = {},
})

gumsMultiDropdown:OnChanged(function(gum)
    config.selectedGums = {}
    for gum, State in next, gum do
        table.insert(config.selectedGums, gum)
    end
end)

local buyGumsToggle = Tabs.Autos:AddToggle("Auto Buy Gums Toggle", 
{
    Title = "Auto Purchase Gums", 
    Default = false,
    Callback = function(v)
        config.autoBuyGums = v
        if v then
            spawn(buyGums)
        end
    end 
})

local flavorsMultiDropdown = Tabs.Autos:AddDropdown("Flavors MultiDropdown", {
    Title = "Flavors",
    Description = "Select flavors to auto purchase.",
    Values = flavorNames,
    Multi = true,
    Default = {},
})

flavorsMultiDropdown:OnChanged(function(flavor)
    config.selectedFlavors = {}
    for flavor, State in next, flavor do
        table.insert(config.selectedFlavors, flavor)
    end
end)

local buyFlavorsToggle = Tabs.Autos:AddToggle("Auto Buy Flavors Toggle", 
{
    Title = "Auto Purchase Flavors", 
    Default = false,
    Callback = function(v)
        config.autoBuyFlavors = v
        if v then
            spawn(buyFlavors)
        end
    end 
})

local shopsSection = Tabs.Autos:AddSection("Shops")

local shopsMultiDropdown = Tabs.Autos:AddDropdown("Shops MultiDropdown", {
    Title = "Shop Items",
    Description = "Select items to auto purchase.",
    Values = shopsData,
    Multi = true,
    Default = {},
})

shopsMultiDropdown:OnChanged(function(selected)
    if selected["Buy All Items"] then
        config.selectedShopItems = {}
        for _, v in ipairs(shopsData) do
            if v ~= "Buy All Items" then
                table.insert(config.selectedShopItems, v)
            end
        end
    else
        config.selectedShopItems = {}
        for i, v in pairs(selected) do
            if v then
                table.insert(config.selectedShopItems, i)
            end
        end
    end
end)

local shopNamesMultiDropdown = Tabs.Autos:AddDropdown("Shops Name MultiDropdown", {
    Title = "Reroll Shops",
    Description = "Select which shops to reroll.",
    Values = shopsName,
    Multi = true,
    Default = {},
})

shopNamesMultiDropdown:OnChanged(function(selected)
    config.selectedRerollShops = {}
    for i, v in pairs(selected) do
        if v then
            table.insert(config.selectedRerollShops, i)
        end
    end
end)

Tabs.Autos:AddParagraph({
    Title = "Info",
    Content = "If you want to open any other guis, you need to disable Auto Shop first."
})

local buyShopItemsToggle = Tabs.Autos:AddToggle("Buy Shop Items Toggle", 
{
    Title = "Auto Buy Shop Items", 
    Default = false,
    Callback = function(v)
        config.autoBuyShopItems = v
        if v then
            spawn(buyShopItems)
        end
    end 
})

local potionCraftingSection = Tabs.Autos:AddSection("Potion Crafting")

local craftingPotionsMultiDropdown = Tabs.Autos:AddDropdown("Crafting Potions MultiDropdown", {
    Title = "Potions",
    Description = "Select the potions to craft.",
    Values = potionsData,
    Multi = true,
    Default = {},
})

craftingPotionsMultiDropdown:OnChanged(function(potion)
    if potion["Craft All Potions"] then
        config.selectedCraftPotions = {}
        for i,v in pairs(potionsData) do
            table.insert(config.selectedCraftPotions, v)
        end
    else
        config.selectedCraftPotions = {}
        for potion, State in next, potion do
            table.insert(config.selectedCraftPotions, potion)
        end
    end
end)

local craftPotionsToggle = Tabs.Autos:AddToggle("Craft Potions Toggle", 
{
    Title = "Auto Craft Potions", 
    Default = false,
    Callback = function(v)
        config.autoCraftPotions = v
        if v then
            spawn(craftPotions)
        end
    end 
})

local consumePotionSection = Tabs.Autos:AddSection("Auto Use Potion")

local potionsToConsumeMultiDropdown = Tabs.Autos:AddDropdown("Potions To Consume MultiDropdown", {
    Title = "Potions",
    Description = "Select potions to use.",
    Values = potions,
    Multi = true,
    Default = {},
})

potionsToConsumeMultiDropdown:OnChanged(function(potion)
    config.selectedConsumePotions = {}
    for potion, State in next, potion do
        table.insert(config.selectedConsumePotions, potion)
    end
end)

local consumePotionsToggle = Tabs.Autos:AddToggle("Consume Potions Toggle", 
{
    Title = "Auto Use Potions", 
    Default = false,
    Callback = function(v)
        config.autoConsumePotions = v
        if v then
            spawn(consumePotions)
        end
    end 
})

local masterySection = Tabs.Autos:AddSection("Mastery")

local masteryMultiDropdown = Tabs.Autos:AddDropdown("Mastery MultiDropdown", {
    Title = "Masteries",
    Description = "Select the masteries to upgrade.",
    Values = masteries,
    Multi = true,
    Default = {},
})

masteryMultiDropdown:OnChanged(function(mastery)
    config.selectedUpgradeMasteries = {}
    for mastery, State in next, mastery do
        table.insert(config.selectedUpgradeMasteries, mastery)
    end
end)

local masteryToggle = Tabs.Autos:AddToggle("Mastery Toggle", 
{
    Title = "Auto Upgrade Mastery", 
    Default = false,
    Callback = function(v)
        config.autoUpgradeMastery = v
        if v then
            spawn(upgradeMastery)
        end
    end 
})

local othersSection = Tabs.Autos:AddSection("Others")

local playtimeToggle = Tabs.Autos:AddToggle("Playtime Toggle", 
{
    Title = "Claim Playtime Rewards", 
    Default = false,
    Callback = function(v)
        config.autoClaimPlaytime = v
        if v then
            spawn(claimPlaytime)
        end
    end 
})

local doggyJumpToggle = Tabs.Autos:AddToggle("Doggy Jump Toggle", 
{
    Title = "Auto Doggy Jump", 
    Default = false,
    Callback = function(v)
        config.autoDoggyJump = v
        if v then
            spawn(doggyJump)
        end
    end 
})

local claimFreeSpinToggle = Tabs.Autos:AddToggle("Claim Free Spin Toggle", 
{
    Title = "Claim Free Wheel Spin", 
    Default = false,
    Callback = function(v)
        config.autoClaimWheelSpin = v
        if v then
            spawn(claimFreeSpin)
        end
    end 
})

local spinWheelToggle = Tabs.Autos:AddToggle("Spin Wheel Toggle", 
{
    Title = "Auto Spin Wheel", 
    Default = false,
    Callback = function(v)
        config.autoSpinWheel = v
        if v then
            spawn(spinWheel)
        end
    end 
})

local openMysteryBoxToggle = Tabs.Autos:AddToggle("Open Mystery Box Toggle", 
{
    Title = "Auto Claim Mystery Box", 
    Default = false,
    Callback = function(v)
        config.autoOpenMysteryBox = v
        if v then
            spawn(openMysteryBox)
        end
    end 
})

local openChestToggle = Tabs.Autos:AddToggle("Open Chest Toggle", 
{
    Title = "Auto Open Chest", 
    Default = false,
    Callback = function(v)
        config.autoOpenChest = v
        if v then
            spawn(openChest)
        end
    end 
})

local farmingMinigame = false

local riftsMultiDropdown = Tabs.Rifts:AddDropdown("Rifts MultiDropdown", {
    Title = "Rifts",
    Description = "Select the rifts you want to farm.",
    Values = rifts,
    Multi = true,
    Default = {},
})

local function parseRiftName(riftName)
    local baseName = riftName:split("|")[1]
    return baseName:match("^%s*(.-)%s*$")
end

riftsMultiDropdown:OnChanged(function(rift)
    config.selectedRifts = {}
    for rift, State in next, rift do
        table.insert(config.selectedRifts, parseRiftName(rift))
    end
end)

config.selectedRiftLuck = tonumber(config.selectedRiftLuck)

local riftLuckDropdown = Tabs.Rifts:AddDropdown("Rift Luck Dropdown", {
    Title = "Rift Luck",
    Description = "Determines if it will farm a rift, will target greater than or equal to.",
    Values = {"5", "10", "25"},
    Multi = false,
    Default = "5",
})

riftLuckDropdown:OnChanged(function(riftLuck)
    config.selectedRiftLuck = tonumber(riftLuck)
end)

local riftPotionsMultiDropdown = Tabs.Rifts:AddDropdown("Rift Potions MultiDropdown", {
    Title = "Rift Potions",
    Description = "Potion to use when a x25 luck rift appears.",
    Values = riftPotions,
    Multi = true,
    Default = {},
})

riftPotionsMultiDropdown:OnChanged(function(riftPotion)
    config.selectedRiftPotions = {}
    for riftPotion, State in next, riftPotion do
        table.insert(config.selectedRiftPotions, riftPotion)
    end
end)

local riftWebhookInput = Tabs.Rifts:AddInput("Rifts Webhook Input", {
    Title = "Discord Webhook",
    Description = "For x25 Luck Rifts.",
    Default = "",
    Numeric = false,
    Finished = false,
    Callback = function(webhook)
        config.selectedRiftWebhook = tostring(webhook)
    end
})

local farmRiftToggle = Tabs.Rifts:AddToggle("Farm Rifts Toggle", 
{
    Title = "Auto Rifts", 
    Default = false,
    Callback = function(v)
        config.autoRifts = v
        if v then
            spawn(farmRifts)
        end
    end 
})

local currentQuest = Tabs.Competitive:AddParagraph({
    Title = "Current Quest",
    Content = "..."
})

local questsIgnoreMultiDropdown = Tabs.Competitive:AddDropdown("Ignore Quests MultiDropdown", {
    Title = "Ignore Quests",
    Values = {"Mythic", "Shiny", "Hatch Amount", "Playtime"},
    Multi = true,
    Default = {},
})

local autoCompToggle
local teleported = false

questsIgnoreMultiDropdown:OnChanged(function(quest)
    config.selectedIgnoreQuest = {}
    for quest, State in next, quest do
        table.insert(config.selectedIgnoreQuest, quest)
    end
    if config.autoCompetitive then
        autoCompToggle:SetValue(false)
        autoCompToggle:SetValue(true)
    end
end)

autoCompToggle = Tabs.Competitive:AddToggle("Auto Comp Toggle", 
{
    Title = "Auto Competitive", 
    Default = false,
    Callback = function(v)
        config.autoCompetitive = v
        if v then
            completeCompQuest()
        else
            currentQuest:SetDesc("Auto Competitive Inactive.")
        end
    end 
})

local currentMinigame = Tabs.Minigames:AddParagraph({
    Title = "Minigame Progress",
    Content = "..."
})

local supaTicketCount = Tabs.Minigames:AddParagraph({
    Title = "Super Tickets",
    Content = "..."
})

Tabs.Minigames:AddToggle("Auto Skip Claw Machine Toggle", 
{
    Title = "Use Super Tickets", 
    Default = false,
    Callback = function(v)
        config.useSuperTicket = v
    end 
})

local clawDifficultyDropdown = Tabs.Minigames:AddDropdown("Claw Difficulty Dropdown", {
    Title = "Robot Claw Difficulty",
    Description = "Select the difficulty you want to farm.",
    Values = {"Easy", "Medium", "Hard", "Insane"},
    Multi = false,
    Default = "Insane",
})

local robotClawIgnoreMultiDropdown = Tabs.Minigames:AddDropdown("Robot Claw Drop Item MultiDropdown", {
    Title = "Ignore Drops",
    Values = clawDrops,
    Multi = true,
    Default = {},
})

robotClawIgnoreMultiDropdown:OnChanged(function(drop)
    config.robotClawDrops = {}
    for drop, State in next, drop do
        table.insert(config.robotClawDrops, drop)
    end
end)

clawDifficultyDropdown:OnChanged(function(difficulty)
    config.selectedDifficulty = difficulty
end)

Tabs.Minigames:AddToggle("Auto Claw Machine Toggle", 
{
    Title = "Auto Claw Machine", 
    Default = false,
    Callback = function(v)
        config.autoClawMachine = v
        if v then
            spawn(clawMachine)
        else
            currentMinigame:SetDesc("Auto Minigame Inactive.")
        end
    end 
})

local webhookInput = Tabs.Webhooks:AddInput("Webhook Input", {
    Title = "Discord Webhook",
    Default = "",
    Numeric = false,
    Finished = false,
    Callback = function(webhook)
        config.selectedWebhook = tostring(webhook)
    end
})

local pingEveryoneToggle = Tabs.Webhooks:AddToggle("Ping Everyone Toggle", 
{
    Title = "Ping @everyone", 
    Default = false,
    Callback = function(v)
        config.hatchingWebhookPingAll = v
    end 
})

local hatchingWebhookSection = Tabs.Webhooks:AddSection("Hatching")

local webhookPetRaritiesMultiDropdown = Tabs.Webhooks:AddDropdown("Webhook Pet Rarity MultiDropdown", {
    Title = "Rarities",
    Values = petsRarity,
    Multi = true,
    Default = {},
})

webhookPetRaritiesMultiDropdown:OnChanged(function(petRarity)
    config.selectedWebhookPetRarities = {}
    for petRarity, State in next, petRarity do
        table.insert(config.selectedWebhookPetRarities, petRarity)
    end
end)

local webhookPetsMultiDropdown = Tabs.Webhooks:AddDropdown("Webhook Pets MultiDropdown", {
    Title = "Pets",
    Values = pets,
    Multi = true,
    Default = {},
})

webhookPetsMultiDropdown:OnChanged(function(pet)
    config.selectedWebhookPets = {}
    for pet, State in next, pet do
        table.insert(config.selectedWebhookPets, pet)
    end
end)

local function getRandomColor()
    local r = math.random(0, 255)
    local g = math.random(0, 255)
    local b = math.random(0, 255)
    return (r * 0x10000) + (g * 0x100) + b
end

local function sendWebhookMessage(embed, discordWebhook)
    pcall(function()
        local payload = {
            embeds = {embed}
        }

        if config.hatchingWebhookPingAll then
            payload.content = "@everyone"
        end

        http_request({
            Url = discordWebhook,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

local function getImageUrl(assetId)
    local apiUrl = string.format(
        "https://thumbnails.roblox.com/v1/assets?assetIds=%d&size=420x420&format=png",
        assetId
    )

    local response = http_request({
        Url = apiUrl,
        Method = "GET",
        Headers = {
            ["User-Agent"] = "Mozilla/5.0"
        }
    })

    if response and response.Body then
        local data = HttpService:JSONDecode(response.Body)
        if data and data.data and data.data[1] then
            return data.data[1].imageUrl
        end
    end
    return nil
end

local webhookToggle = Tabs.Webhooks:AddToggle("Webhook Toggle", {
    Title = "Hatching Webhook",
    Default = false,
    Callback = function(v)
        config.hatchingWebhook = v
        if v and not getgenv().hatchHook then
            hatchingModule.Play = function(...)
                local args = {...}
                for _, arg in pairs(args) do
                    if typeof(arg) == "table" and arg.Pets then
                        for _, petData in pairs(arg.Pets) do
                            local pet = petData.Pet
                            if pet and pet.Name and pet.Shiny ~= nil then
                                local petName = tostring(pet.Name)
                                local petInfo = petsData[petName]

                                local matchesRarity = petInfo and table.find(config.selectedWebhookPetRarities, petInfo.Rarity)
                                local matchesSpecific = table.find(config.selectedWebhookPets, petName)

                                if matchesRarity or matchesSpecific then
                                    local hatchType
                                    if pet.Mythic and pet.Shiny then
                                        hatchType = "a Mythic Shiny"
                                    elseif pet.Mythic then
                                        hatchType = "a Mythic"
                                    elseif pet.Shiny then
                                        hatchType = "a Shiny"
                                    else
                                        hatchType = "a"
                                    end

                                    local imageId = petInfo and (
                                        pet.Mythic and pet.Shiny and petInfo.MythicShiny or
                                        pet.Mythic and petInfo.Mythic or
                                        pet.Shiny and petInfo.Shiny or
                                        petInfo.Normal
                                    )

                                    local embed = {
                                        title = "BGSI Hatch Alert",
                                        description = lp.Name .. " hatched " .. hatchType .. " " .. petName .. "!",
                                        color = getRandomColor(),
                                        image = {
                                            url = getImageUrl(tonumber(imageId))
                                        },
                                        fields = {
                                            {
                                                name = "Rarity",
                                                value = petInfo and petInfo.Rarity or "Unknown",
                                                inline = true
                                            },
                                            {
                                                name = "Chance",
                                                value = petInfo and petInfo.Chance.."%" or "Unknown",
                                                inline = true
                                            }
                                        },
                                        footer = {
                                            text = "Lenut Hub - " .. os.date("%c")
                                        }
                                    }                                    
                                    sendWebhookMessage(embed, config.selectedWebhook)
                                end
                            end
                        end
                    end
                end
                return config.hatchAnimation(...)
            end

            getgenv().hatchHook = true

        elseif not v and getgenv().hatchHook then
            hatchingModule.Play = config.hatchAnimation
            getgenv().hatchHook = false
        end
    end
})

local robotClawWebhookSection = Tabs.Webhooks:AddSection("Robot Claw")

local robotClawWebhookToggle = Tabs.Webhooks:AddToggle("Robot Claw Webhook Toggle", 
{
    Title = "Robot Claw Webhook", 
    Default = false,
    Callback = function(v)
        config.sendRobotClawWebhook = v
        if v then
            robotClawWebhook()
        end
    end 
})

Tabs.Misc:AddButton({
    Title = "Unlock All Islands",
    Callback = function()
        unlockAllIslands()
    end
})

Tabs.Misc:AddButton({
    Title = "Claim Codes",
    Callback = function()
        claimAllCodes()
    end
})

Tabs.Misc:AddButton({
    Title = "Debug",
    Callback = function()
        for i,v in pairs(config) do
            print(i,v)
        end
    end
})


InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:SetLibrary(Fluent)
SaveManager:SetFolder("ja5on7190/BGSI")
SaveManager:BuildConfigSection(Tabs.Settings)

--Functions

local function getPlayerWorld()
    return worldUtil:GetPlayerWorld(lp)
end

local Noclipping = nil
local Clip = false

local function NoclipLoop()
    if Clip == false and lp.Character ~= nil then
        for _, child in pairs(lp.Character:GetDescendants()) do
            if child:IsA("BasePart") and child.CanCollide == true then
                child.CanCollide = false
            end
        end
    end
end

local tweening = false

function TweenToGoal(targetCFrame, Speed, offset)
    if not offset then
        offset = 20
    end

    if not Speed then
        Speed = lp.Character.Humanoid.WalkSpeed
    end
    tweening = true
    Noclipping = RunService.Stepped:Connect(NoclipLoop)
    local chr = lp.Character or lp.CharacterAdded:Wait()
    local dist = (chr.PrimaryPart.Position - Vector3.new(targetCFrame.X, chr.PrimaryPart.Position.Y, targetCFrame.Z)).Magnitude
    local TweenInfoToUse = TweenInfo.new(dist / Speed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)

    local TweenValue = Instance.new("CFrameValue")
    TweenValue.Value = chr:GetPrimaryPartCFrame()

    TweenValue.Changed:Connect(function()
        local tp = TweenValue.Value
        chr:PivotTo(CFrame.new(tp.X, targetCFrame.Position.Y + offset, tp.Z))
        chr.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
    end)

    getfenv().tween = TweenService:Create(TweenValue, TweenInfoToUse, { Value = targetCFrame })
    getfenv().tween:Play()

    repeat
        task.wait()
    until getfenv().tween.PlaybackState == Enum.PlaybackState.Cancelled or getfenv().tween.PlaybackState == Enum.PlaybackState.Completed

    Noclipping:Disconnect()
    tweening = false
end

local function checkPasses(passName)
    local plrData = localData.Get()

    if plrData and plrData.Passes and plrData.Passes[passName] and plrData.Passes[passName] ~= false then
        return true
    end
    return false
end

function blowBubble()
    while true do
        if config.autoBlowBubble then
            local plrData = localData.Get()
            local bubbleAmount = plrData.Bubble.Amount
            local bubbleStorage
            if checkPasses("Infinity Gum") then
                bubbleStorage = 1/0
            else
                bubbleStorage = statsUtil.GetBubbleStorage(statsUtil, plrData)
            end
            if bubbleAmount < bubbleStorage then
                Network.FireServer("Event", "BlowBubble")
            end
        end
        task.wait(0.1)
    end
end

local function findBestSellZone(world)
    local plrData = localData.Get()
    local sell
    local sellWorld

    for i, v in pairs(workspace.Worlds[world]:GetDescendants()) do
        if v and v.Name == "Sell" and v:IsA("Model") then
            if v.Parent and v.Parent.Name == "Island" 
                and v.Parent.Parent and v.Parent.Parent:IsA("Folder") 
                and v.Parent.Parent:GetAttribute("Height") 
                and plrData.AreasUnlocked[v.Parent.Parent.Name] then

                sell = v
                sellWorld = "Workspace.Worlds." .. world .. ".Islands." .. v.Parent.Parent.Name .. ".Island"
                break

            elseif not sell and v.Parent and v.Parent.Name == world then
                sell = v
                sellWorld = "Workspace.Worlds." .. world
            end
        end
    end
    return sell, sellWorld
end

local cd = 0.5
local oldCFrame

function sellBubble()
    while true do
        if config.autoSellBubble then
            local bestSell, bestSellZone = findBestSellZone(getPlayerWorld())
            if config.autoHatch then
                cd = 3
            else
                cd = 0.1
            end
            if bestSell and bestSellZone and lp and lp.Character and lp.Character.PrimaryPart then
                oldCFrame = lp.Character.PrimaryPart.CFrame
                if not tweening then
                    if oldCFrame then
                        Network.FireServer("Event","Teleport", bestSellZone..".Sell.Root")
                        task.wait(cd)
                        for i = 1,5 do
                            Network.FireServer("Event", "SellBubble")
                            task.wait(0.1)
                        end
                        TweenToGoal(oldCFrame)
                    end
                else
                    return
                end
            end
        end
        task.wait(config.sellBubbleCooldown)
    end
end

function findClosestCoin()
    local coin
    local closest = 1/0

    for i,v in pairs(workspace.Rendered:GetDescendants()) do
        if v and v:IsA("MeshPart") and (v.Name:find("Coin") or v.Name:find("coin") or v.Name:find("Ticket") or v.Name:find("ticket")) and v.Parent:IsA("Model") and v.Parent.Parent.Name == "Chunker" then
            if lp and lp.Character and lp.Character.PrimaryPart then
                local distance = (lp.Character.PrimaryPart.Position - v.Position).Magnitude
                if distance < closest then
                    closest = distance
                    coin = v.Parent.Name
                end
            end
        end
    end
    return coin
end

function equipBestPet()
    while true do
        if config.equipBest then
            Network.FireServer("Event", "EquipBestPets")
        end
        task.wait(5)
    end
end

local function isCloseToEgg(eggName)
    for i,v in pairs(workspace.Rendered:GetChildren()) do
        if v.Name == "Chunker" and v:IsA("Folder") then
            if v:FindFirstChild(eggName) then
                local egg = v:FindFirstChild(eggName)
                local distance = (lp.Character.PrimaryPart.Position - egg:GetPivot().Position).Magnitude
                if distance < 15 then
                    return true
                end
            end
        end
    end
    return false
end

function hatchEgg()
    while true do
        if config.autoHatch then
            if config.selectedHatchEgg == "" then
                hatchingToggle:SetValue(false)
                Fluent:Notify({
                    Title = "Missing Egg",
                    Content = "Select an Egg...",
                    Duration = 10
                })
            end
            if isCloseToEgg(config.selectedHatchEgg) then
                local plrData = localData.Get()
                local hatchAmount = statsUtil.GetMaxEggHatches(statsUtil, plrData)
                Network.FireServer("Event", "HatchEgg", config.selectedHatchEgg, hatchAmount)
            end
        end
        task.wait(0.1)
    end
end

local function getHighestIsland(world)
    local highestIsland
    local lowest = -1/0

    for i,v in pairs(workspace.Worlds[world].Islands:GetChildren()) do
        if v and v:IsA("Folder") and v:GetAttribute("Height") then
            if v:GetAttribute("Height") > lowest then
                lowest = v:GetAttribute("Height")
                highestIsland = v:FindFirstChildOfClass("Model")
            end
        end
    end
    return highestIsland
end

local function parseEnchant(enchantStr)
    local id, level = string.match(enchantStr, "(.+)%-(%d+)$")
    if id and level then
        return {
            Id = id,
            Level = tonumber(level)
        }
    end
    return nil
end

function Enchant()
    while true do
        if config.autoEnchant then
            local plrData = localData.Get()
            local matchedPetCount = 0

            for _, pet in pairs(plrData.Pets) do
                if table.find(config.selectedEnchantPets, pet.Id) then
                    local hasMatch = false

                    for _, selectedEnchant in pairs(config.selectedEnchants) do
                        local parsedSelected = parseEnchant(selectedEnchant)

                        if parsedSelected and pet.Enchants then
                            for _, petEnchant in pairs(pet.Enchants) do
                                if petEnchant.Id == parsedSelected.Id and petEnchant.Level == parsedSelected.Level then
                                    hasMatch = true
                                    break
                                end
                            end
                        end

                        if hasMatch then break end
                    end

                    if hasMatch then
                        matchedPetCount += 1
                    else
                        Network.InvokeServer("Function", "RerollEnchants", pet.Id)
                    end
                end
            end

            if matchedPetCount == #config.selectedEnchantPets then
                enchantingToggle:SetValue(false)
                Fluent:Notify({
                    Title = "Enchanting Complete!",
                    Content = "All selected pets got the selected enchant...",
                    Duration = 10
                })
            end
        end
        task.wait(0.1)
    end
end

local function checkOwnedGums(gumName)
    local plrData = localData.Get()
    local ownedGums = plrData.Gum

    for i,v in pairs(ownedGums) do
        if i == gumName and v then
            return true
        end
    end
    return false
end

function buyGums()
    while true do
        if config.autoBuyGums then
            local plrData = localData.Get()
            local coins = plrData.Coins

            for _,v in pairs(config.selectedGums) do
                if not checkOwnedGums(v) and coins > gums[v].Cost then
                    Network.FireServer("Event", "GumShopPurchase", v)
                end
            end
        end
        task.wait(1)
    end
end

local function checkOwnedFlavors(flavorName)
    local plrData = localData.Get()
    local ownedFlavors = plrData.Flavors

    for i,v in pairs(ownedFlavors) do
        if i == flavorName and v then
            return true
        end
    end
    return false
end

function buyFlavors()
    while true do
        if config.autoBuyFlavors then
            local plrData = localData.Get()
            local coins = plrData.Coins
            local ownedFlavors = plrData.Flavors

            for _,v in pairs(config.selectedFlavors) do
                if not checkOwnedFlavors(v) and coins > flavors[v].Cost then
                    Network.FireServer("Event", "GumShopPurchase", v)
                end
            end
        end
        task.wait(1)
    end
end

function parseProductString(formatted)
    local function trim(s)
        return s and s:match("^%s*(.-)%s*$") or nil
    end

    local shopName, name, type, level

    shopName, name, type, level = string.match(
        formatted,
        "^(.-)%s*|%s*(.-)%s*%((%w+)%s*LVL%s*(%d+)%)"
    )

    if not name then
        shopName, name, type = string.match(
            formatted,
            "^(.-)%s*|%s*(.-)%s*%((%w+)%)"
        )
    end

    return {
        ShopName = trim(shopName),
        Name = trim(name),
        Type = trim(type),
        Level = level and tonumber(level) or nil
    }
end

local function shopTrueName(displayName)
    local trueName

    for i,v in pairs(shopsModule) do
        if v.DisplayName == displayName then
            trueName = i
        end
    end
    return trueName
end

local function romanConverter(roman)
    local romanMap = {
        I = 1,
        V = 5,
        X = 10,
        L = 50,
        C = 100,
        D = 500,
        M = 1000
    }

    local total = 0
    local prevValue = 0

    for i = #roman, 1, -1 do
        local char = roman:sub(i, i)
        local value = romanMap[char]

        if not value then
            error("Invalid Roman numeral character: " .. char)
        end

        if value < prevValue then
            total = total - value
        else
            total = total + value
        end

        prevValue = value
    end

    return total
end

local function getStock(shop, name, level)
    local shopModule = require(game.ReplicatedStorage.Client.Gui.Frames.ItemShop)
    local guiModule = require(game:GetService("ReplicatedStorage").Client.Gui.GuiFrame)
    local shopFrame = lp.PlayerGui.ScreenGui:FindFirstChild("ItemShop")

    local totalItems = 0
    local outOfStockItems = 0
    local matchedStock = nil
    local rerollsLeft = 0

    shopModule:SetShopId(shop)
    guiModule:Open("ItemShop")

    for i,v in pairs(shopFrame:GetDescendants()) do
        if v.Name == "Amount" and v:IsA("TextLabel") and v.Parent.Name == "Button" and v.Parent.Parent.Name == "Reroll" then
            local rerollAmount = v.ContentText:gsub(" remaining", "")
            rerollsLeft = tonumber(rerollAmount)
        end
    end

    for i, v in pairs(shopFrame:GetDescendants()) do
        if v.Name:find("Item") and v.Parent.Name == "ScrollingFrame" then
            totalItems += 1
            local stockField = v:FindFirstChild("Stock")
            if not stockField then continue end

            local itemStockText = stockField.ContentText
            local outOfStock = itemStockText:find("Out")

            if outOfStock then
                outOfStockItems += 1
                itemStockText = "0"
            else
                itemStockText = itemStockText:gsub(" in stock", "")
            end            

            local itemHolder = v:FindFirstChild("Frame")
            if itemHolder then
                local itemFrame = itemHolder:FindFirstChild("ItemFrame")
                if itemFrame then
                    local itemButton = itemFrame:FindFirstChild("Button")
                    if itemButton then
                        local itemInner = itemButton:FindFirstChild("Inner")
                        if itemInner then
                            local itemLabel = itemInner:FindFirstChild("Label")
                            if itemLabel then
                                local labelText = itemLabel.ContentText
                                local itemName = nil
                                local romanLevel = nil

                                if labelText:find("Evolved") then
                                    itemName = labelText:gsub(" Evolved", "")
                                    romanLevel = "Evolved"
                                elseif labelText:match("^(.-) (%u+)$") then
                                    itemName, romanLevel = labelText:match("^(.-) (%u+)$")
                                else
                                    itemName = labelText
                                end

                                if itemName == name then
                                    if level == nil and not outOfStock then
                                        matchedStock = tonumber(itemStockText) or 0
                                    elseif romanLevel and level and not outOfStock then
                                        local levelNumber
                                        if romanLevel == "Evolved" then
                                            levelNumber = 6
                                        else
                                            levelNumber = romanConverter(romanLevel)
                                        end
                                        if levelNumber == level then
                                            matchedStock = tonumber(itemStockText) or 0
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    local allowedShops = {}
    for _, v in pairs(config.selectedRerollShops) do
        table.insert(allowedShops, shopTrueName(v))
    end
    
    if totalItems > 0 and outOfStockItems == totalItems and rerollsLeft > 0 and table.find(allowedShops, shop) then
        Network.FireServer("Event", "ShopFreeReroll", shop)
    end    

    guiModule:Close()

    return matchedStock or 0
end

local function getShopCurrency(shop)
    local plrData = localData.Get()
    return shopsUtil:GetItemsData(shop, lp, plrData)[1].Cost.Currency
end

local function canAfford(shop, name, level)
    local plrData = localData.Get()
    local plrCurrency = plrData[getShopCurrency(shop)]

    for i,v in pairs(shopsUtil:GetItemsData(shop, lp, plrData)) do
        if level then
            if v.Product.Name == name and v.Product and v.Product.Level == level and plrCurrency > v.Cost.Amount then
                return true
            end
        else
            if v.Product.Name == name and plrCurrency > v.Cost.Amount then
                return true
            end
        end
    end
    return false
end

function buyShopItems()
    while true do
        if config.autoBuyShopItems then
            local plrData = localData.Get()

            for _, itemString in pairs(config.selectedShopItems) do
                local itemData = parseProductString(itemString)

                if itemData and itemData.Name and itemData.ShopName then
                    local shopName = shopTrueName(itemData.ShopName)
                    local items = shopsUtil:GetItemsData(shopName, lp, plrData)

                    for i, v in pairs(items) do
                        if typeof(v) == "table" and v.Product then
                            local product = v.Product
                            local productName = product.Name
                            local productLevel = product.Level
                            local productType = product.Type

                            if productName == itemData.Name and productType == itemData.Type then
                                local isMatchingLevel = (productLevel and itemData.Level and productLevel == itemData.Level)
                                local isLevelNilMatch = (not productLevel and not itemData.Level)

                                if isMatchingLevel and canAfford(shopName, productName, productLevel) then
                                    if getStock(shopName, productName, productLevel) > 0 then
                                        Network.FireServer("Event", "BuyShopItem", shopName, i)
                                    end
                                elseif isLevelNilMatch and canAfford(shopName, productName) then
                                    if getStock(shopName, productName, nil) > 0 then
                                        Network.FireServer("Event", "BuyShopItem", shopName, i)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.1)
            end
        end
        task.wait()
    end
end

local function parsePotionString(potionName)
    local name, level = string.match(potionName, "^(.-)%s+(%d+)$")

    if name and level then
        return name:match("^%s*(.-)%s*$"), tonumber(level)
    else
        return potionName, nil
    end
end

local function getPotionCost(name, level)
    if craftCosts[name] and craftCosts[name][level] then
        return craftCosts[name][level].PotionCost, craftCosts[name][level].GemCost
    end
    return nil, nil
end

local function getPotionAmount(name, level)
    local plrData = localData.Get()
    for _, v in pairs(plrData.Potions) do
        if v.Name == name and v.Level == level then
            return v.Amount
        end
    end
    return 0
end

local function getGemCount()
    local plrData = localData.Get()
    return plrData.Gems
end

function craftPotions()
    while true do
        if config.autoCraftPotions then
            for i,v in pairs(config.selectedCraftPotions) do
                local name, level = parsePotionString(v)
                if name and level then
                    local potCost, gemCost = getPotionCost(name, level-1)
                    if getPotionAmount(name, level-1) >= potCost and getGemCount() >= gemCost then
                        Network.FireServer("Event", "CraftPotion", name, level, true)
                    end
                end
                task.wait(0.5)
            end
        end
        task.wait(5)
    end
end

local function hasEnoughPotion(potionName, potionLevel)
    local plrData = localData.Get()
    local plrPotions = plrData.Potions

    for i,v in pairs(plrPotions) do
        if v.Name == potionName and v.Level == potionLevel and v.Amount > 0 then
            return true
        end
    end
    return false
end

local function usePotion(name, level)
    local plrData = localData.Get()
    local activePotions = plrData.ActivePotions

    if name and level then
        if activePotions[name] and activePotions[name].Active.Level >= level then
            do end
        else
            if hasEnoughPotion(name, level) then 
                while true do
                    local plrData = localData.Get()
                    local activePotions = plrData.ActivePotions
                    if activePotions[name] and activePotions[name].Active.Level >= level then
                        break
                    else
                        Network.FireServer("Event", "UsePotion", name, level) 
                    end
                    task.wait(0.1)
                end
            end
        end
    end
end

function consumePotions()
    while true do
        if config.autoConsumePotions then
            for i,v in pairs(config.selectedConsumePotions) do
                local name, level = parsePotionString(v)
                usePotion(name, level)
                task.wait(0.5)
            end
        end
        task.wait(1)
    end
end

function upgradeMastery()
    while true do
        if config.autoUpgradeMastery then
            for i,v in pairs(config.selectedUpgradeMasteries) do
                Network.FireServer("Event", "UpgradeMastery", v)
                task.wait(0.5)
            end
        end
        task.wait(1)
    end
end

function claimPlaytime()
    while true do
        if config.autoClaimPlaytime then
            for i = 1,9 do
                Network.InvokeServer("Function", "ClaimPlaytime", i)
                task.wait(0.5)
            end 
        end     
        task.wait(3)
    end
end

function doggyJump()
    while true do
        if config.autoDoggyJump then
            local plrData = localData.Get()
            local len = #doggyJumpUtil.PrizeScores
            local refreshPeriod = doggyJumpUtil.RefreshPeriod

            if plrData.DoggyJump.Claimed < len then
                Network.FireServer("Event", "DoggyJumpWin", 3)
            end

            local waitTime = plrData.DoggyJump.Began + refreshPeriod - timeModule.now()
            if waitTime > 0 then
                task.wait(math.max(1, waitTime) + 1)
            end
        end
        task.wait()
    end
end

function claimFreeSpin()
    while true do
        if config.autoClaimWheelSpin then
            local plrData = localData.Get()
            local nextSpin = plrData.NextWheelSpin
            local now = os.time()
        
            if not nextSpin or nextSpin <= now then
                Network.FireServer("Event", "ClaimFreeWheelSpin")
                task.wait(1)
            else
                task.wait(nextSpin - now + 1)
            end
        end
        task.wait(10)
    end
end

function spinWheel()
    while true do
        if config.autoSpinWheel then
            local plrData = localData.Get()
        
            local tickets = plrData.Powerups["Spin Ticket"] or 0
        
            if tickets > 0 then
                Network.InvokeServer("Function", "WheelSpin")
            end
        end
        task.wait(10)
    end
end

function openMysteryBox()
    while true do
        if config.autoOpenMysteryBox then
            local plrData = localData.Get()
            local amount = plrData.Powerups["Mystery Box"] or 0

            if amount > 0 then
                Network.FireServer("Event", "UseGift", "Mystery Box", amount)
                task.wait(1)
                for _, v in pairs(workspace.Rendered.Gifts:GetChildren()) do
                    if v and v:IsA("Part") then
                        Network.FireServer("Event", "ClaimGift", v.Name)
                        --local giftPosition = v.Position
                        --local giftObject = giftModule.new(v, giftPosition)
                        --giftObject:Destroy()
                    end
                end
            end
        end
        task.wait(0.5)
    end
end

function openChest()
    while true do
        if config.autoOpenChest then
            local plrData = localData.Get()
            for i,v in pairs(chests) do
                if plrData.Cooldowns and plrData.Cooldowns[v] and plrData.Cooldowns[v] - os.time() <= 0 then
                    task.wait(1)
                    Network.FireServer("Event", "ClaimChest", v, true)
                    task.wait(0.5)
                end
            end
        end
        task.wait(5)
    end
end

local function capitalize(str)
    return (str:sub(1,1):upper() .. str:sub(2):lower())
end

local usedChests = {}
local usedPotions = {}
local autoHatchEggName

function farmRifts()
    local currentRift = nil
    local oldCFrame = nil
    local returnedToOld = false
    local isBusy = false
    local wasAutoHatchOn = false
    local turnedToTrue = false
    local savedOldEgg = false
    local previousRift = nil

    if config.autoHatch then
        autoHatchEggName = config.selectedHatchEgg
    end

    while true do
        if config.autoRifts then
            local plrData = localData.Get()
            local matchingRifts = {}
            local chestSelected = false
            local onlyChestsSelected = true
            local royalChest = nil
            local normalChests = {}

            for _, name in ipairs(config.selectedRifts) do
                if name:lower():find("chest") then
                    chestSelected = true
                else
                    onlyChestsSelected = false
                end
            end

            for _, rift in pairs(workspace.Rendered.Rifts:GetChildren()) do
                if table.find(config.selectedRifts, rift.Name) then
                    local isChest = rift.Name:lower():find("chest")
                    if rift.Name:lower() == "royal-chest" then
                        local chestKey = "Royal Key"
                        if plrData.Powerups[chestKey] and plrData.Powerups[chestKey] > 0 and not usedChests[rift.Name] then
                            royalChest = rift
                        end
                    elseif isChest then
                        table.insert(normalChests, rift)
                    else
                        local display = rift:FindFirstChild("Display")
                        if display then
                            local sGui = display:FindFirstChild("SurfaceGui")
                            if sGui then
                                local icon = sGui:FindFirstChild("Icon")
                                if icon then
                                    local luck = icon:FindFirstChild("Luck")
                                    if luck and luck:IsA("TextLabel") then
                                        local luck = luck.Text:gsub("x", "")
                                        local luckValue = tonumber(luck)
                                        if luckValue and luckValue >= config.selectedRiftLuck then
                                            table.insert(matchingRifts, rift)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(0.1)
            end

            if royalChest and not isBusy then
                isBusy = true
                currentRift = nil

                if not oldCFrame then
                    oldCFrame = lp.Character.PrimaryPart.CFrame
                end

                local chestPos = royalChest:GetPivot().Position
                if (lp.Character.PrimaryPart.Position - chestPos).Magnitude > 10 then
                    TweenToGoal(CFrame.new(chestPos))
                end

                local success = true

                while true do
                    local plrData = localData.Get()
                    local chestKey = "Royal Key"
                    local amount = plrData.Powerups[chestKey] or 0
                
                    if amount <= 0 or not royalChest or not royalChest:IsDescendantOf(workspace) or not config.autoRifts then
                        success = false
                        break
                    else
                        Network.FireServer("Event", "UnlockRiftChest", royalChest.Name, false)
                    end
                    task.wait(0.1)
                end            

                if success then
                    usedChests[royalChest.Name] = true
                end

                TweenToGoal(oldCFrame)
                returnedToOld = false
                isBusy = false
                
                if config.autoHatch and savedOldEgg then
                    eggsDropdown:SetValue(autoHatchEggName)
                    savedOldEgg = false
                elseif turnedToTrue then
                    hatchingToggle:SetValue(false)
                    turnedToTrue = false
                end

            elseif not isBusy then
                if #matchingRifts > 0 then
                    local bestRift = nil
                    
                    local manEggRifts = {}
                    local nonManRifts = {}

                    for _, rift in ipairs(matchingRifts) do
                        local display = rift:FindFirstChild("Display")
                        if display then
                            local sGui = display:FindFirstChild("SurfaceGui")
                            local icon = sGui and sGui:FindFirstChild("Icon")
                            local timer = sGui and sGui:FindFirstChild("Timer")

                            if icon and timer then
                                local luckLabel = icon:FindFirstChild("Luck")
                                if luckLabel and luckLabel:IsA("TextLabel") then
                                    local luckText = luckLabel.Text:gsub("x", "")
                                    local luckValue = tonumber(luckText)

                                    if luckValue then
                                        if luckValue >= 25 and not usedPotions[rift] then
                                            for _, potion in pairs(config.selectedRiftPotions) do
                                                local name, level = parsePotionString(potion)
                                                usePotion(name, level)
                                                task.wait(0.5)
                                            end
                                            local embed = {
                                                title = "BGSI Rift Alert",
                                                description = "A x25 Luck "..rift.Name.." has spawned, despawns in "..timer.Text..".",
                                                color = getRandomColor(),
                                                footer = { text = "Lenut Hub - " .. os.date("%c") }
                                            }
                                            sendWebhookMessage(embed, config.selectedRiftWebhook)
                                            usedPotions[rift] = true
                                        end

                                        if rift.Name:lower():find("man") then
                                            table.insert(manEggRifts, {rift = rift, luck = luckValue})
                                        else
                                            table.insert(nonManRifts, {rift = rift, luck = luckValue})
                                        end
                                    end
                                end
                            end
                        end
                    end

                    local function getBestByLuck(riftList)
                        local best = nil
                        local maxLuck = -math.huge
                        for _, data in ipairs(riftList) do
                            if data.luck > maxLuck then
                                best = data.rift
                                maxLuck = data.luck
                            end
                        end
                        return best
                    end

                    if #manEggRifts > 0 then
                        bestRift = getBestByLuck(manEggRifts)
                    else
                        bestRift = getBestByLuck(nonManRifts)
                    end                

                    if bestRift then
                        if currentRift and currentRift ~= bestRift and previousRift ~= bestRift then
                            if config.autoHatch and savedOldEgg then
                                eggsDropdown:SetValue(autoHatchEggName)
                                savedOldEgg = false
                            elseif turnedToTrue then
                                hatchingToggle:SetValue(false)
                                turnedToTrue = false
                            end
                        end
                        
                        previousRift = currentRift
                        currentRift = bestRift
                    end

                    if currentRift then
                        if not oldCFrame then
                            oldCFrame = lp.Character.PrimaryPart.CFrame
                        end

                        local targetPos = currentRift:GetPivot().Position
                        if (lp.Character.PrimaryPart.Position - targetPos).Magnitude > 10 and not tweening then
                            TweenToGoal(CFrame.new(targetPos))
                        end

                        local hatchAmount = statsUtil.GetMaxEggHatches(statsUtil, plrData)
                        
                        if config.autoHatch and not savedOldEgg then
                            eggsDropdown:SetValue(riftName[currentRift.Name])
                            wasAutoHatchOn = true
                            savedOldEgg = true
                        elseif not config.autoHatch then
                            while true do
                                if not config.autoRifts then break end
                                if not farmingMinigame then
                                    eggsDropdown:SetValue(riftName[currentRift.Name])
                                    hatchingToggle:SetValue(true)
                                    turnedToTrue = true
                                    break
                                end
                                task.wait()
                            end
                        end
                    end
                elseif #normalChests > 0 and chestSelected then
                    for _, rift in ipairs(normalChests) do
                        local chestType = rift.Name:gsub("-chest", "")
                        local chestKey = capitalize(chestType) .. " Key"
                        local amount = plrData.Powerups[chestKey] or 0

                        if amount > 0 and not usedChests[rift.Name] then
                            isBusy = true
                            if not oldCFrame then
                                oldCFrame = lp.Character.PrimaryPart.CFrame
                            end

                            local chestPos = rift:GetPivot().Position
                            if (lp.Character.PrimaryPart.Position - chestPos).Magnitude > 10 then
                                TweenToGoal(CFrame.new(chestPos))
                            end

                            local success = true

                            while true do
                                local plrData = localData.Get()
                                local amount = plrData.Powerups[chestKey] or 0
                            
                                if amount <= 0 or not rift or not rift:IsDescendantOf(workspace) or not config.autoRifts then
                                    success = false
                                    break
                                else
                                    Network.FireServer("Event", "UnlockRiftChest", rift.Name, false)
                                end
                                task.wait(0.1)
                            end   

                            if success then
                                usedChests[rift.Name] = true
                            end

                            TweenToGoal(oldCFrame)
                            returnedToOld = false
                            isBusy = false
                            
                            if config.autoHatch and savedOldEgg then
                                eggsDropdown:SetValue(autoHatchEggName)
                                savedOldEgg = false
                            elseif turnedToTrue then
                                hatchingToggle:SetValue(false)
                                turnedToTrue = false
                            end
                            
                            break
                        end
                        task.wait(0.1)
                    end
                elseif oldCFrame and not returnedToOld and not tweening then
                    if wasAutoHatchOn and savedOldEgg then
                        eggsDropdown:SetValue(autoHatchEggName)
                        savedOldEgg = false
                        wasAutoHatchOn = false
                    elseif turnedToTrue then
                        hatchingToggle:SetValue(false)
                        turnedToTrue = false
                    end
                    TweenToGoal(oldCFrame)
                    returnedToOld = true
                end                     
            end
        end
        task.wait(0.1)
    end
    
    if wasAutoHatchOn and savedOldEgg then
        eggsDropdown:SetValue(autoHatchEggName)
    elseif turnedToTrue then
        hatchingToggle:SetValue(false)
    end
end   

local lastHatches
local lastChangeTime = tick()

task.spawn(function()
    while true do
        if config.autoHatch then
            local plrData = localData.Get()
            local hatches = plrData.Stats.Hatches

            if lastHatches == nil then
                lastHatches = hatches
                lastChangeTime = tick()
            end

            if hatches ~= lastHatches then
                lastChangeTime = tick()
                lastHatches = hatches
            end

            if tick() - lastChangeTime >= 60 then
                local data = eggsData[config.selectedHatchEgg]
                local destination

                if data.World and data.Island ~= data.World then
                    destination = "Workspace.Worlds." .. data.World .. ".Islands." .. data.Island .. ".Island.Portal.Spawn"
                else
                    destination = "Workspace.Worlds." .. data.Island .. ".PortalSpawn"
                end

                Network.FireServer("Event", "Teleport", destination)
                task.wait(1)

                local player = game.Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

                local closest
                local shortestDistance = 1/0

                for _, v in pairs(workspace.Rendered.Generic:GetChildren()) do
                    if v:IsA("Model") and v.Name == config.selectedHatchEgg then
                        local distance = (v:GetPivot().Position - humanoidRootPart.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            closest = v
                        end
                    end
                end

                if closest then
                    TweenToGoal(closest.PrimaryPart.CFrame)
                end

                local eggMain = autoHatchEggName and autoHatchEggName or config.selectedHatchEgg

                eggsDropdown:SetValue(eggMain)
                hatchingToggle:SetValue(false)
                task.wait(0.1)
                hatchingToggle:SetValue(true)
                task.wait(0.1)
                farmRiftToggle:SetValue(false)
                task.wait(0.1)
                farmRiftToggle:SetValue(true)
                lastChangeTime = tick()
            end
        end
        task.wait(0.1)
    end
end)

local blacklistedEggs = {"Aura Egg", "Season 1 Egg", "Series 1 Egg", "Silly Egg", "100M Egg", "Throwback Egg"}

local function findEasiestPetEgg(rarity)
    local easiestEgg
    local highest = -1/0

    for i,v in pairs(petsModule) do
        if v.Rarity == rarity and v.Chance and v.Egg and not table.find(blacklistedEggs, v.Egg) then
            if v.Chance > highest then
                highest = v.Chance
                easiestEgg = v.Egg
            end
        end
    end
    return easiestEgg
end

local function findEgg(eggName)
    local egg
    local closest = 1/0

    if eggName ~= "Common Egg" then
        for i,v in pairs(workspace.Rendered.Generic:GetChildren()) do
            if v:IsA("Model") and v.Name == eggName then
                local distance = (lp.Character.PrimaryPart.Position - v:GetPivot().Position).Magnitude
                if distance < closest then
                    closest = distance
                    egg = v:GetPivot().Position
                end
            end
        end
    else
        for i,v in pairs(workspace.Rendered.Generic:GetChildren()) do
            if v:IsA("Model") and v.Name == "Common Egg" then
                local distance = (Vector3.new(-11.895793, 9.33136845, -93.9566879) - v:GetPivot().Position).Magnitude
                if distance < closest then
                    closest = distance
                    egg = v:GetPivot().Position
                end
            end
        end
    end
    return egg
end

local function countTableKeys(t)
    local count = 0
    for _ in pairs(t) do
        count += 1
    end
    return count
end

local questPriorities = {
    ["Hatch Egg"] = 1,
    ["Hatch Rarity"] = 2,
    ["Hatch Amount"] = 3,
    ["Hatch Shiny"] = 4,
    ["Hatch Mythic"] = 5,
    ["Playtime"] = 6
}

function getQuestPriority(quest)
    if not quest then return 999 end
    
    local questTask = quest.Tasks[1]
    local questType = getQuestType(questTask)
    
    return questPriorities[questType] or 999
end

function getQuestType(questTask)
    if questTask.Type == "Hatch" and questTask.Egg and questTask.Egg ~= nil and questTask.Amount then
        return "Hatch Egg"
    elseif questTask.Type == "Hatch" and questTask.Amount and not questTask.Egg and countTableKeys(questTask) == 2 then
        return "Hatch Amount"
    elseif questTask.Type == "Hatch" and questTask.Mythic then
        return "Hatch Mythic"
    elseif questTask.Type == "Hatch" and questTask.Rarity then
        return "Hatch Rarity"
    elseif questTask.Type == "Hatch" and questTask.Shiny then
        return "Hatch Shiny"
    elseif questTask.Type == "Playtime" then
        return "Playtime"
    end
end

function handleCompetitiveQuest(quest, questTask, progress, hatchAmount)
    local plrData = localData.Get()

    local function teleportToEgg(egg)
        if lp and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local data = eggsData[egg]
            if not data or not data.Island then return end
    
            local destination
    
            if data.World and data.Island ~= data.World then
                destination = "Workspace.Worlds." .. data.World .. ".Islands." .. data.Island .. ".Island.Portal.Spawn"
            else
                destination = "Workspace.Worlds." .. data.Island .. ".PortalSpawn"
            end
    
            local eggPos = findEgg(egg)
            local needsTeleport = true
    
            if eggPos and lp.Character.PrimaryPart then
                local distance = (lp.Character.PrimaryPart.Position - eggPos).Magnitude
                if distance <= 20 then
                    needsTeleport = false
                end
            end
    
            if needsTeleport and not teleported then
                local startTime = os.clock()
                while os.clock() - startTime < 0.5 do
                    if not config.autoCompetitive then return end
                    Network.FireServer("Event", "Teleport", destination)
                    task.wait()
                end
                teleported = true
            end
    
            eggPos = findEgg(egg)
            if eggPos and lp.Character.PrimaryPart and (lp.Character.PrimaryPart.Position - eggPos).Magnitude > 15 then
                if not config.autoCompetitive then return end
                TweenToGoal(CFrame.new(eggPos), nil, 5)
            end
        end
    end    

    local questType = getQuestType(questTask)

    if questType == "Hatch Egg" then
        teleportToEgg(questTask.Egg)
        Network.FireServer("Event", "HatchEgg", questTask.Egg, hatchAmount)
        if not config.autoCompetitive then return end
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " " .. questTask.Egg .. "\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Shiny" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        if not config.autoCompetitive then return end
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Shinies\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Mythic" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        if not config.autoCompetitive then return end
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Mythics\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Playtime" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        if not config.autoCompetitive then return end
        local desc = "Current Quest: Playtime " .. questTask.Amount .. "\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Amount" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        if not config.autoCompetitive then return end
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Eggs\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Rarity" then
        local easiestEgg = findEasiestPetEgg(questTask.Rarity)
        if easiestEgg then
            teleportToEgg(easiestEgg)
            Network.FireServer("Event", "HatchEgg", easiestEgg, hatchAmount)
            if not config.autoCompetitive then return end
            local desc = "Current Quest: Hatch " .. questTask.Amount .. " " .. questTask.Rarity .. "\nProgress: " .. progress .. "/" .. questTask.Amount
            task.spawn(function()
                currentQuest:SetDesc(desc)
            end)
            task.wait(0.1)
            return true
        end
    end
    return false
end

previousIgnoreTable = {}

function saveIgnoreTable()
    previousIgnoreTable = table.clone(config.selectedIgnoreQuest)
end

function restoreIgnoreTable()
    config.selectedIgnoreQuest = previousIgnoreTable
end

local currentHandledQuest = nil

function completeCompQuest()
    teleported = false
    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local hatchAmount = statsUtil:GetMaxEggHatches(plrData)
            local comp3 = questsUtil:FindById(plrData, "competitive-3")
            local comp4 = questsUtil:FindById(plrData, "competitive-4")
            local didHandle = false

            local function isQuestIgnored(q)
                if not q then return true end
                local task = q.Tasks[1]
                if task.Type == "Hatch" and task.Shiny then return table.find(config.selectedIgnoreQuest, "Shiny") end
                if task.Type == "Hatch" and task.Mythic then return table.find(config.selectedIgnoreQuest, "Mythic") end
                if task.Type == "Playtime" then return table.find(config.selectedIgnoreQuest, "Playtime") end
                if task.Type == "Hatch" and task.Amount and not task.Egg and countTableKeys(task) == 2 then return task.Amount > 1000 and table.find(config.selectedIgnoreQuest, "Hatch Amount") end            
                return false
            end

            local comp3Ignored = isQuestIgnored(comp3)
            local comp4Ignored = isQuestIgnored(comp4)
            
            local comp3Priority = not comp3Ignored and getQuestPriority(comp3) or 999
            local comp4Priority = not comp4Ignored and getQuestPriority(comp4) or 999
            
            if currentHandledQuest then
                local currentQuestId = currentHandledQuest.Id
                if (comp3Priority < comp4Priority and currentQuestId ~= comp3.Id) or 
                (comp4Priority < comp3Priority and currentQuestId ~= comp4.Id) then
                    teleported = false
                end
            end
            
            if comp3Priority <= comp4Priority and not comp3Ignored then
                currentHandledQuest = comp3
                didHandle = handleCompetitiveQuest(comp3, comp3.Tasks[1], comp3.Progress[1], hatchAmount)
            elseif not comp4Ignored then
                currentHandledQuest = comp4
                didHandle = handleCompetitiveQuest(comp4, comp4.Tasks[1], comp4.Progress[1], hatchAmount)
            end
            
            if not didHandle and not comp3Ignored and currentHandledQuest ~= comp3 then
                currentHandledQuest = comp3
                didHandle = handleCompetitiveQuest(comp3, comp3.Tasks[1], comp3.Progress[1], hatchAmount)
            elseif not didHandle and not comp4Ignored and currentHandledQuest ~= comp4 then
                currentHandledQuest = comp4
                didHandle = handleCompetitiveQuest(comp4, comp4.Tasks[1], comp4.Progress[1], hatchAmount)
            end

            if not didHandle then
                currentHandledQuest = nil
                local rrOrb = plrData.Powerups["Reroll Orb"]

                if comp3Ignored and comp4Ignored then
                    if not rrOrb or rrOrb <= 5 then
                        saveIgnoreTable()
                        config.selectedIgnoreQuest = {}
                    else
                        if comp3 then
                            local questId = comp3.Id:gsub("competitive--", "")
                            questId = tonumber(questId)
                            Network.FireServer("Event", "CompetitiveReroll", questId)
                        end
                        if comp4 then
                            local questId = comp4.Id:gsub("competitive--", "")
                            questId = tonumber(questId)
                            Network.FireServer("Event", "CompetitiveReroll", questId)
                            task.wait(1)
                        end
                        autoCompToggle:SetValue(false)
                        autoCompToggle:SetValue(true)
                    end
                end
                teleported = false
            end
        end
        task.wait()
    end
end

task.spawn(function()
    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local currentRerollCount = plrData.Powerups["Reroll Orb"]

            if currentRerollCount and currentRerollCount > 5 and #config.selectedIgnoreQuest == 0 then
                restoreIgnoreTable()
                autoCompToggle:SetValue(false)
                autoCompToggle:SetValue(true)
            end
        end
        task.wait(1)
    end
end)

task.spawn(function()
    local lastComp3Progress = 0
    local lastComp4Progress = 0
    local wasNonZero3 = false
    local wasNonZero4 = false
    
    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local comp3 = questsUtil:FindById(plrData, "competitive-3")
            local comp4 = questsUtil:FindById(plrData, "competitive-4")
            
            if comp3 and comp3.Progress and comp3.Progress[1] > 0 then
                wasNonZero3 = true
                lastComp3Progress = comp3.Progress[1]
            elseif wasNonZero3 and comp3 and comp3.Progress and comp3.Progress[1] == 0 and lastComp3Progress > 0 then
                wasNonZero3 = false
                teleported = false
                currentHandledQuest = nil
            end
            
            if comp4 and comp4.Progress and comp4.Progress[1] > 0 then
                wasNonZero4 = true
                lastComp4Progress = comp4.Progress[1]
            elseif wasNonZero4 and comp4 and comp4.Progress and comp4.Progress[1] == 0 and lastComp4Progress > 0 then
                wasNonZero4 = false
                teleported = false
                currentHandledQuest = nil
            end
        end
        task.wait()
    end
end)

task.spawn(function()
    local plrData = localData.Get()
    local lastHatchCount = plrData.Stats.Hatches
    local lastChangeTime = nil

    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local currentHatchCount = plrData.Stats.Hatches

            if currentHatchCount ~= lastHatchCount then
                lastHatchCount = currentHatchCount
                lastChangeTime = os.clock()
            elseif lastChangeTime and (os.clock() - lastChangeTime >= 20) then
                autoCompToggle:SetValue(false)
                autoCompToggle:SetValue(true)
                lastChangeTime = os.clock()
            end
        else
            lastChangeTime = nil
        end
        task.wait(0.1)
    end
end)

local function isGuidItemInGame(guid)
    for i,v in pairs(lp.PlayerGui.ScreenGui:GetChildren()) do
        if v.Name:find(guid, 1, true) then
            local icon = v:FindFirstChild("Icon")
            if icon then
                local frame = icon:FindFirstChildOfClass("Frame")
                if frame and frame.Name:find("Infinity") then return false end
                if frame and frame.Name:find("Elixir") then return false end
                if frame and frame.Name:find("infinity") then return false end
                if frame and frame.Name:find("elixir") then return false end
                if frame and frame.Name:find("Potion") then
                    local potion = frame.Name:gsub("Potion", "")
                    local potionName, potionLevel = potion:match("^(%a+)(%d+)$")
                    local potionStr = potionName and potionName .. " | " .. potionLevel or ""
                    for ii,vv in pairs(config.robotClawDrops) do
                        if vv:find(potionStr) then
                            return true
                        end
                    end
                else
                    local imageLab = icon:FindFirstChildOfClass("ImageLabel")
                    if imageLab then
                        for iii,vvv in pairs(config.robotClawDrops) do
                            if imageLab and imageLab.Image and powerIcons[imageLab.Image] then
                                if vvv:find(powerIcons[imageLab.Image]) then
                                    return true
                                elseif imageLab and imageLab.Image and petAssets[imageLab.Image] then
                                    if vvv:find(petAssets[imageLab.Image]) then
                                        return true
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return false
end

local function getAllUnCollectedToys()
    local clawMachine = workspace:FindFirstChild("ClawMachine")
    if not clawMachine then
        task.spawn(function()
            currentMinigame:SetDesc("No claw machine found!")
        end)
        return {}
    end

    local uncollectedToys = {}

    for _, toy in pairs(clawMachine:GetChildren()) do
        if toy:IsA("Model") and toy:FindFirstChild("HitBox") and toy:HasTag("ClawToyModel") then
            local guid = toy:GetAttribute("ItemGUID")
            local wasCollected = toy:GetAttribute("wasCollected")

            if guid and not wasCollected and not isGuidItemInGame(guid) then
                table.insert(uncollectedToys, toy)
            end
        end
    end
    return uncollectedToys
end

local function getNameFromGUID(guid)
    for i,v in pairs(lp.PlayerGui.ScreenGui:GetChildren()) do
        if v.Name:find(guid, 1, true) then
            local icon = v:FindFirstChild("Icon")
            if icon then
                local frame = icon:FindFirstChildOfClass("Frame")
                if frame and frame.Name:find("Infinity") then return "Infinity Elixir" end
                if frame and frame.Name:find("Elixir") then return "Infinity Elixir" end
                if frame and frame.Name:find("infinity") then return "Infinity Elixir" end
                if frame and frame.Name:find("elixir") then return "Infinity Elixir" end
                if frame and frame.Name:find("Potion") then
                    local potion = frame.Name:gsub("Potion", "")
                    local potionName, potionLevel = potion:match("^(%a+)(%d+)$")
                    local potionStr = potionName and potionName .. " | " .. potionLevel or ""
                    return potionStr
                else
                    local imageLab = icon:FindFirstChildOfClass("ImageLabel")
                    if imageLab and imageLab.Image and powerIcons[imageLab.Image] then
                        return powerIcons[imageLab.Image]
                    elseif imageLab and imageLab.Image and petAssets[imageLab.Image] then
                        return petAssets[imageLab.Image]
                    end
                end
            end
        end
    end
    return "Unknown"
end

local collectedItems = {}
local gamesPlayed = 0

local function collectAllClawItems()
    local maxAttempts = 5
    local attemptCount = 0
    local waitBetweenChecks = 0
    local waitAfterCollection = 3.2
    local collectedAny = false

    local clawMachine = workspace:FindFirstChild("ClawMachine")
    local totalToysInMachine = 0
    if clawMachine then
        for _, toy in pairs(clawMachine:GetChildren()) do
            if toy:IsA("Model") and toy:FindFirstChild("HitBox") and toy:HasTag("ClawToyModel") then
                totalToysInMachine += 1
            end
        end
    end

    while attemptCount < maxAttempts do
        local uncollectedToys = getAllUnCollectedToys()

        if attemptCount == 0 and totalToysInMachine > 0 and #uncollectedToys == 0 then
            task.spawn(function()
                currentMinigame:SetDesc("No collectible toys found. Exiting minigame.")
            end)

            local closeButton = lp.PlayerGui.ScreenGui.MinigameHUD["Robot Claw"]:FindFirstChild("Close")
            if closeButton then
                firesignal(closeButton["Activated"])
                task.wait(0.5)
            end
            if lp.PlayerGui.ScreenGui:FindFirstChild("Prompt") then
                for _, v in pairs(lp.PlayerGui.ScreenGui.Prompt.Frame.Main:FindFirstChild("Buttons"):GetDescendants()) do
                    if v:IsA("TextLabel") and v.Name == "Label" and v.Text == "Leave" then
                        firesignal(v.Parent["Activated"])
                        break
                    end
                end
            end

            return false
        end

        if #uncollectedToys == 0 then
            task.spawn(function()
                currentMinigame:SetDesc("All toys collected! Finishing game...")
            end)
            task.wait(1)
            return true
        end

        task.spawn(function()
            currentMinigame:SetDesc("Found " .. #uncollectedToys .. " toys to collect (Attempt " .. (attemptCount + 1) .. "/" .. maxAttempts .. ")")
        end)

        for _, toy in pairs(uncollectedToys) do
            local guid = toy:GetAttribute("ItemGUID")
            if guid then
                collectedAny = true
                local toyName = getNameFromGUID(guid)
                task.spawn(function()
                    currentMinigame:SetDesc("Collecting toy: " .. toyName)
                end)
                table.insert(collectedItems, toyName)
                Network.FireServer("Event", "GrabMinigameItem", guid)
                toy:SetAttribute("wasCollected", true)
                task.wait(waitAfterCollection)

                local stillExists = false
                for _, checkToy in pairs(getAllUnCollectedToys()) do
                    if checkToy:GetAttribute("ItemGUID") == guid then
                        stillExists = true
                        break
                    end
                end

                if stillExists then
                    task.spawn(function()
                        currentMinigame:SetDesc("Re-attempting to collect: " .. guid)
                    end)
                    Network.FireServer("Event", "GrabMinigameItem", guid)
                    task.wait(waitAfterCollection)
                else
                    task.spawn(function()
                        currentMinigame:SetDesc("Successfully collected: " .. guid)
                    end)
                end
            end
        end

        task.wait(waitBetweenChecks)
        attemptCount += 1
    end

    local remainingToys = getAllUnCollectedToys()
    if #remainingToys == 0 then
        task.spawn(function()
            currentMinigame:SetDesc("All toys collected after retries!")
        end)
        return true
    else
        task.spawn(function()
            currentMinigame:SetDesc("Warning: " .. #remainingToys .. " toys couldn't be collected!")
        end)
        return true
    end
end

local minigameInProgress = false
local configRestored = false
local oldConfig = {}

local function deepCopy(original)
    local copy
    if type(original) == "table" then
        copy = {}
        for k, v in pairs(original) do
            copy[k] = deepCopy(v)
        end
    else
        copy = original
    end
    return copy
end

function monitorClawConfigRestoration()
    local cooldownDisplay = nil

    task.spawn(function()
        while true do
            if config.autoClawMachine then
                local plrData = localData.Get()
                local superTickets = plrData.Powerups["Super Ticket"] and plrData.Powerups["Super Ticket"] or 0
                local cooldown = plrData.Cooldowns["Robot Claw"] or 0
                local currentTime = os.time()
                local timeRemaining = cooldown - currentTime

                if not minigameInProgress and ((config.useSuperTicket and superTickets == 0 and timeRemaining > 0) or 
                    (not config.useSuperTicket and timeRemaining > 0)) then
                    
                    if not configRestored and next(oldConfig) ~= nil then
                        for k, v in pairs(oldConfig) do
                            if typeof(config[k]) == "boolean" then
                                config[k] = v
                            end
                        end                        
                        configRestored = true
                        task.spawn(function()
                            currentMinigame:SetDesc("Restored previous config due to cooldown with no Super Ticket")
                        end)
                        oldConfig = {}
                    end
                        

                    local displayTime = math.ceil(timeRemaining)
                    if not cooldownDisplay or cooldownDisplay ~= displayTime then
                        cooldownDisplay = displayTime
                        task.spawn(function()
                            currentMinigame:SetDesc("On cooldown: " .. displayTime .. "s remaining")
                        end)
                    end
                end
            end
            task.wait(0.1)
        end
    end)
end

spawn(monitorClawConfigRestoration)

function clawMachine()
    while true do
        if config.autoClawMachine then
            local plrData = localData.Get()
            local superTickets = plrData.Powerups["Super Ticket"] and plrData.Powerups["Super Ticket"] or 0
            local cooldown = plrData.Cooldowns["Robot Claw"] and plrData.Cooldowns["Robot Claw"] or 0
            local currentTime = os.time()
            local timeRemaining = cooldown - currentTime

            if not minigameInProgress then
                if timeRemaining <= 0 or (config.useSuperTicket and superTickets > 0) then
                    if next(oldConfig) == nil then
                        for k, v in pairs(config) do
                            if typeof(v) == "boolean" then
                                oldConfig[k] = v
                            end
                        end
                    end                    
                    if configRestored then
                        configRestored = false
                        task.spawn(function()
                            currentMinigame:SetDesc(timeRemaining <= 0 and "Cooldown expired, resuming auto-claw" or "Using Super Ticket")
                        end)
                    end

                    for i, v in pairs(config) do
                        if typeof(v) == "boolean" then
                            config[i] = false
                        end
                    end

                    config.autoClawMachine = true

                    if config.useSuperTicket then
                        if not oldConfig[useSuperTicket] then
                            oldConfig[useSuperTicket] = true
                        end
                    end

                    minigameInProgress = true
                    farmingMinigame = true

                    task.spawn(function()
                        currentMinigame:SetDesc(superTickets > 0 and "Starting Robot Claw...")
                    end)

                    if superTickets > 0 then
                        while true do
                            if not config.autoClawMachine then break end
                            local gameGui = lp.PlayerGui.ScreenGui.MinigameHUD
                            if gameGui and not gameGui.Visible then
                                task.wait(3)
                                break
                            end
                            task.wait(0.1)
                        end

                        task.wait(3)
                        Network.FireServer("Event", "SkipMinigameCooldown", "Robot Claw")
                    else
                        task.wait(3)
                    end

                    local startTime = os.clock()
                    while os.clock() - startTime < 1 do
                        Network.FireServer("Event", "StartMinigame", "Robot Claw", config.selectedDifficulty)
                        task.wait()
                    end

                    while true do
                        if not config.autoClawMachine then break end
                        local gameGui = lp.PlayerGui.ScreenGui.MinigameHUD
                        if gameGui and gameGui.Visible then
                            task.wait(3)
                            break
                        end
                        task.wait(0.1)
                    end

                    local allCollected = collectAllClawItems()

                    if allCollected then
                        task.spawn(function()
                            currentMinigame:SetDesc("Finishing Robot Claw minigame")
                        end)
                        Network.FireServer("Event", "FinishMinigame")
                        gamesPlayed = gamesPlayed + 1
                    end

                    minigameInProgress = false
                    farmingMinigame = false
                end
            end
        end
        task.wait(0.1)
    end
end

function robotClawWebhook()
    while true do
        if config.sendRobotClawWebhook then
            collectedItems = {}
            gamesPlayed = 0
            task.wait(600)

            local itemCounts = {}
            for _, item in ipairs(collectedItems) do
                --if item and item ~= "" then
                itemCounts[item] = (itemCounts[item] or 0) + 1
                --end
            end            

            local formattedItems = {}
            for itemName, count in pairs(itemCounts) do
                table.insert(formattedItems, string.format("%s (%d)", itemName, count))
            end

            local message = table.concat(formattedItems, "\n")
            local embed = {
                title = "Robot Claw Farming Stats",
                description = "In 10 Minutes " .. lp.Name .. " has completed " .. gamesPlayed .. " games and collected:" .. "\n\n" .. message,
                color = getRandomColor(),
                footer = { text = "Lenut Hub - " .. os.date("%c") }
            }
            sendWebhookMessage(embed, config.selectedWebhook)
        end
        task.wait()
    end
end

task.spawn(function()
    while true do
        if config.autoClawMachine then
            local claimButton = lp.PlayerGui.ScreenGui:FindFirstChild("Prompt")
            if claimButton then
                firesignal(claimButton.Frame.Main.Buttons.Template.Button["Activated"])
            end
        end
        task.wait()
    end
end)

task.spawn(function()
    while true do
        if config.autoClawMachine then
            local plrData = localData.Get()
            local superTickets = plrData.Powerups["Super Ticket"] and plrData.Powerups["Super Ticket"] or 0

            task.spawn(function()
                supaTicketCount:SetDesc("You currently have " .. superTickets .. " Super Tickets")
            end)
        end
        task.wait(0.1)
    end
end)

task.spawn(function()
    while task.wait(0.5) do
        local found = false

        for _, v in pairs(CoreGui:GetChildren()) do
            if v:IsA("ScreenGui") and v:GetAttribute("Animations") then
                found = truel

                break
            end
        end

        if not found then
            config.hatchingWebhook = false
            hatchingModule.Play = config.hatchAnimation
            getgenv().hatchHook = false
            break
        else
            do end
        end
    end
end)

function unlockAllIslands()
    local plrData = localData.Get()
    if plrData.AreasUnlocked[getHighestIsland(getPlayerWorld()).Parent.Name] then
        task.spawn(function()
            Fluent:Notify({
                Title = "Status",
                Content = "You've already unlocked all islands...",
                Duration = 10
            })
        end)
        return
    end
    local highestIsland = getHighestIsland(getPlayerWorld()):GetPivot().Position

    if highestIsland then
        Network.FireServer("Event", "Teleport", "Workspace.Worlds.".. getPlayerWorld() .. ".PortalSpawn")
        task.wait(1.2)
        if lp and lp.Character and lp.Character.PrimaryPart then
            local dist = (lp.Character.PrimaryPart.Position - highestIsland).Magnitude
            local dest = CFrame.new(highestIsland) + Vector3.new(0, 50, 0)
            local TweenInfoToUse = TweenInfo.new(dist / 3000, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)

            local TweenValue = Instance.new("CFrameValue")
            TweenValue.Value = lp.Character:GetPrimaryPartCFrame()

            TweenValue.Changed:Connect(function()
                lp.Character:PivotTo(TweenValue.Value)
                lp.Character.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
            end)
    
            local OnTween = TweenService:Create(TweenValue, TweenInfoToUse, { Value = dest })
            OnTween:Play()
            OnTween.Completed:Wait()
        end
    end
end

function claimAllCodes()
    for i,v in pairs(codes) do
        Network.InvokeServer("Function", "RedeemCode", v)
        task.wait(0.1)
    end
end

SaveManager:LoadAutoloadConfig()
