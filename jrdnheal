local scriptStatus = loadstring(game:HttpGet("https://pastebin.com/raw/tETBwUZF"))()
if not scriptStatus then return end

if not game:IsLoaded() then game.Loaded:Wait() end 

local config = {
    autoBlowBubble = false,
    autoSellBubble = false,
    sellBubbleCooldown = 10,
    collectDrops = false,
    oldPickupRange = nil,
    equipBest = false,
    selectedHatchEgg = "",
    autoHatch = false,
    hatchAnimation = nil,
    hatchAnimationState = false,
    selectedEnchantPets = {},
    selectedEnchants = {},
    autoEnchant = false,
    selectedGums = {},
    autoBuyGums = false,
    selectedFlavors = {},
    autoBuyFlavors = false,
    selectedShopItems = {},
    autoBuyShopItems = false,
    selectedCraftPotions = {},
    autoCraftPotions = false,
    selectedConsumePotions = {},
    autoConsumePotions = false,
    selectedUpgradeMasteries = {},
    autoUpgradeMastery = false,
    autoClaimPlaytime = false,
    autoDoggyJump = false,
    autoClaimWheelSpin = false,
    autoSpinWheel = false,
    autoOpenMysteryBox = false,
    selectedRifts = {},
    selectedRiftLuck = "5",
    selectedRiftPotions = {},
    selectedRiftWebhook = "",
    autoRifts = false,
    selectedWebhookPetRarities = {},
    selectedWebhookPets = {},
    selectedHatchingWebhook = "",
    hatchingWebhookPingAll = false,
    hatchingWebhook = false,
    autoOpenChest = false,
    selectedIgnoreQuest = {},
    autoCompetitive = false,
}

local lp = game:GetService("Players").LocalPlayer
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local afkScript = lp:WaitForChild("PlayerScripts", 9e9):WaitForChild("AFK", 9e9)
local introGui = lp.PlayerGui:FindFirstChild("Intro")
local Network = require(ReplicatedStorage.Shared.Framework.Network.Remote)
local localData = require(ReplicatedStorage.Client.Framework.Services.LocalData)
local statsUtil = require(ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local eggsModule = require(ReplicatedStorage.Shared.Data.Eggs)
local hatchingModule = require(ReplicatedStorage.Client.Effects.HatchEgg)
local petsModule = require(ReplicatedStorage.Shared.Data.Pets)
local enchantsModule = require(ReplicatedStorage.Shared.Data.Enchants)
local gumsModule = require(ReplicatedStorage.Shared.Data.Gum)
local flavorsModule = require(ReplicatedStorage.Shared.Data.Flavors)
local codesModule = require(ReplicatedStorage.Shared.Data.Codes)
local shopsModule = require(ReplicatedStorage.Shared.Data.Shops)
local shopsUtil = require(ReplicatedStorage.Shared.Utils.ShopUtil)
local potionsModule = require(ReplicatedStorage.Shared.Data.Potions)
local masteryModule = require(ReplicatedStorage.Shared.Data.Mastery)
local doggyJumpUtil = require(ReplicatedStorage.Shared.Utils.DoggyJumpUtil)
local timeModule = require(ReplicatedStorage.Shared.Framework.Utilities.Math.Time)
local giftModule = require(ReplicatedStorage.Client.Effects.PhysicalItem.Gift)
local riftsModule = require(ReplicatedStorage.Shared.Data.Rifts)
local chestsModule = require(ReplicatedStorage.Shared.Data.Chests)
local questsUtil = require(ReplicatedStorage.Shared.Utils.Stats.QuestUtil)

local function populateTable(moduleSrc, tbl)
    for i,v in pairs(moduleSrc) do
        table.insert(tbl, i)
    end
    table.sort(tbl)
end

local eggs = {"Infinity Egg"}
local eggsData = {}
local pets = {}
local enchants =  {}
local gums = {}
local flavors = {}
local gumNames = {}
local flavorNames = {}
local codes = {}
local shopsData = {"Buy All Items"}
local potionsData = {"Craft All Potions"}
local potions = {}
local masteries = {}
local rifts = {}
local riftName = {}
local petsRarity = {}
local petsData = {}
local riftPotions = {}
local chests = {}

populateTable(eggsModule, eggs)
populateTable(petsModule, pets)
populateTable(codesModule, codes)
populateTable(chestsModule, chests)

for i,v in pairs(enchantsModule) do
    for ii,vv in pairs(v) do
        local levels = v.Levels
        if levels then
            for iii = 1,levels do
                table.insert(enchants, tostring(i.."-"..iii))
            end
        end
        break
    end
end

for i,v in pairs(gumsModule) do
    if i ~= "Infinity Gum" and i ~= "VIP Gum" then
        gums[i] = {
            Cost = v.Cost.Amount
        }
    end
end

for i, _ in pairs(gums) do
    table.insert(gumNames, i)
end

for i,v in pairs(flavorsModule) do
    if i ~= "VIP Flavor" then
        flavors[i] = {
            Cost = v.Cost.Amount
        }
    end
end

for i, _ in pairs(flavors) do
    table.insert(flavorNames, i)
end

for i, v in pairs(shopsModule) do
    for ii, vv in pairs(v.RandomItems) do
        local product = vv.Product
        if typeof(product) == "table" then
            local formatted = string.format(
                "%s | %s (%s%s)",
                v.DisplayName,
                product.Name,
                product.Type,
                product.Level and (" LVL " .. product.Level) or ""
            )
            table.insert(shopsData, formatted)
        end
    end
end

for i, v in pairs(shopsModule) do
    for ii, vv in pairs(v.PermanentItems) do
        local product = vv.Product
        if typeof(product) == "table" then
            local formatted = string.format(
                "%s | %s (%s%s)",
                v.DisplayName,
                product.Name,
                product.Type,
                product.Level and (" LVL " .. product.Level) or ""
            )
            table.insert(shopsData, formatted)
        end
    end
end

for i, v in pairs(potionsModule) do
    if v.CraftingCosts and i ~= "Infinity Elixir" then
        for level = 2, #v.CraftingCosts+1 do
            table.insert(potionsData, i .. " " .. level)
        end
    end
end

for i, v in pairs(potionsModule) do
    if v.CraftingCosts then
        for level = 1, #v.CraftingCosts+2 do
            table.insert(potions, i .. " " .. level)
        end
    else
        table.insert(potions, i .. " " .. "1")
    end
end

for i,v in pairs(potionsModule) do
    if v.CraftingCosts then
        for level = 6, #v.CraftingCosts+2 do
            table.insert(riftPotions, i .. " " .. level)
        end
    else
        table.insert(riftPotions, i .. " " .. "1")
    end
end

for i,v in pairs(masteryModule.Upgrades) do
    table.insert(masteries, i)
end

for i,v in pairs(riftsModule) do
    if not i:find("gift") then
        if v.Egg then
            table.insert(rifts, i.." | "..v.Egg)
        else
            table.insert(rifts, i)
        end
    end
end

for i,v in pairs(riftsModule) do
    riftName[i] = v.Egg
end

for i, v in pairs(petsModule) do
    if not table.find(petsRarity, v.Rarity) then
        table.insert(petsRarity, v.Rarity)
    end
end

for i, v in pairs(petsModule) do
    local images = v.Images or {}

    petsData[i] = {
        Normal = (images.Normal and images.Normal:gsub("rbxassetid://", "")) or nil,
        Shiny = (images.Shiny and images.Shiny:gsub("rbxassetid://", "")) or nil,
        Mythic = (images.Mythic and images.Mythic:gsub("rbxassetid://", "")) or nil,
        MythicShiny = (images.MythicShiny and images.MythicShiny:gsub("rbxassetid://", "")) or nil,
        Rarity = v.Rarity,
        Chance = v.Chance
    }
end

for i,v in pairs(eggsModule) do
    if v.Island then
        eggsData[i] = {
            Island = v.Island
        }
    elseif not v.Island and v.World then
        eggsData[i] = {
            Island = v.World
        }
    end
end

if introGui and introGui.Enabled then
    local loadingLabel = lp.PlayerGui.Intro.Logo.Bar.Label
    while task.wait() do
        if loadingLabel.Text == "100%" then
            break
        end
    end
    local playButton = lp.PlayerGui.Intro.Play.Button
    local lowGraphicsButton = lp.PlayerGui.Intro.Graphics.Content.Low.Action.Button

    if playButton and lowGraphicsButton and playButton.Visible and lowGraphicsButton.Visible then
        task.wait(2)
        firesignal(playButton["Activated"])
        firesignal(lowGraphicsButton["Activated"])
        task.wait(3)
    end
end

for i, v in pairs(getgc()) do
    if typeof(v) == "function" and getfenv(v).script == afkScript then
        local info = debug.getinfo(v)
        if info.name:find("onIdled") then
            hookfunction(v, function(...)
                return
            end)
        end
    end
end

for i,v in pairs(getconnections(lp.Idled)) do v:Disable() end

local Fluent = loadstring(game:HttpGet("https://pastebin.com/raw/ivKf0LFW"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local Window = Fluent:CreateWindow({
    Title = "BGSI (WIP) - ja5on7190",
    --SubTitle = "by Developers at Lunor",
    TabWidth = 160,
    Size = UDim2.fromOffset(500, 425),
    Acrylic = false,
    Theme = "Obsidian Glow",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Mobile = Window:AddTab({ Title = "Mobile", Icon = "rbxassetid://10734921524" }),
    Farming = Window:AddTab({ Title = "Farming", Icon = "rbxassetid://10709811110" }),
    Pets = Window:AddTab({ Title = "Pets", Icon = "rbxassetid://10723345518" }),
    Autos = Window:AddTab({ Title = "Autos", Icon = "rbxassetid://10709782230" }),
    Rifts = Window:AddTab({ Title = "Rifts", Icon = "rbxassetid://10723417608" }),
    Competitive = Window:AddTab({ Title = "Competitive", Icon = "rbxassetid://10734962068" }),
    Webhooks = Window:AddTab({ Title = "Webhooks", Icon = "rbxassetid://10747366606" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://10709797985" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://10709810948" })
}

InterfaceManager:SetLibrary(Fluent)
SaveManager:SetLibrary(Fluent)

Window:SelectTab(1)

for i,v in pairs(CoreGui:GetDescendants()) do
    if v:IsA("TextLabel") and v.Text:find("BGSI") and v.Parent.Parent.Parent.Parent:IsA("ScreenGui") and v.Parent.Parent.Parent.Parent.Name == "ScreenGui" then
        v.Parent.Parent.Parent.Parent:SetAttribute("Animations", true)
    end
end

Tabs.Mobile:AddButton({
    Title = "Mobile Helper",
    Callback = function()    
        for i,v in pairs(CoreGui:GetDescendants()) do
            if v.Name == "Lebutton" then
                return
            end
        end
        local gui = Instance.new("ScreenGui")
        gui.Parent = CoreGui
        local button = Instance.new("TextButton")
        button.Text = "Hide/Show"
        button.Name = "Lebutton"
        button.BackgroundColor3 = Color3.new(1, 1, 1)
        button.Size = UDim2.new(0, 75, 0, 75)
        button.Position = UDim2.new(0.5, -button.Size.X.Offset / 2, 0, -50)
        button.Transparency = 0
        button.Parent = gui

        local uicorner = Instance.new("UICorner")
        uicorner.CornerRadius = UDim.new(0, 100)
        uicorner.Parent = button

        button.TextSize = 10
        button.TextColor3 = Color3.new(0, 0, 0)

        local function ToggleVisibility()
            for _, v in pairs(CoreGui:GetDescendants()) do
                if v:IsA("Frame") and v.Size.X.Offset == 500 and v.Size.Y.Offset == 425 and v.Parent:IsA("ScreenGui") then
                    v.Visible = not v.Visible
                end
            end
        end
            
        if UserInputService.TouchEnabled then
            button.Activated:Connect(ToggleVisibility)
        else
            button.MouseButton1Click:Connect(ToggleVisibility)
        end
    end
})

local blowBubbleToggle = Tabs.Farming:AddToggle("Blow Bubble Toggle", 
{
    Title = "Auto Blow Bubble", 
    Default = false,
    Callback = function(v)
        config.autoBlowBubble = v
        if v then
            spawn(blowBubble)
        end
    end 
})

local sellBubbleToggle = Tabs.Farming:AddToggle("Sell Bubble Toggle", 
{
    Title = "Auto Sell Bubble", 
    Description = "Configurations below.",
    Default = false,
    Callback = function(v)
        config.autoSellBubble = v
        if v then
            spawn(sellBubble)
        end
    end 
})

if config.oldPickupRange == nil then
    config.oldPickupRange = statsUtil.GetPickupRange
end

local collectDropsToggle = Tabs.Farming:AddToggle("Collect Drops Toggle", 
{
    Title = "Collect Drops", 
    Description = "Will collect coins and gems.",
    Default = false,
    Callback = function(v)
        config.collectDrops = v
        if v then
            statsUtil.GetPickupRange = function()
                return 1/0
            end
        else
            statsUtil.GetPickupRange = config.oldPickupRange
        end
    end 
})

task.spawn(function()
    while true do
        if config.collectDrops then
            local coin = findClosestCoin()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Pickups"):WaitForChild("CollectPickup"):FireServer(coin)            
        end
        task.wait(0.5)
    end
end)

local equipBestToggle = Tabs.Farming:AddToggle("Equip Best Toggle", 
{
    Title = "Auto Equip Best", 
    Default = false,
    Callback = function(v)
        config.equipBest = v
        if v then
            spawn(equipBestPet)
        end
    end 
})

local farmSettingsSection = Tabs.Farming:AddSection("Autofarm Settings")

local sellBubbleCooldownInput = Tabs.Farming:AddInput("Sell Bubble Cooldown Input", {
    Title = "Sell Bubble Cooldown (sec)",
    Description = "This determines how \noften it sells the bubble.",
    Numeric = true,
    Finished = false,
    Callback = function(cd)
        config.sellBubbleCooldown = cd
    end
})

local eggsDropdown = Tabs.Pets:AddDropdown("Eggs Dropdown", {
    Title = "Eggs",
    Description = "Select egg to hatch.",
    Values = eggs,
    Multi = false,
    Default = "",
})

eggsDropdown:OnChanged(function(egg)
    config.selectedHatchEgg = egg
end)

local hatchingToggle = Tabs.Pets:AddToggle("Hatching Toggle", 
{
    Title = "Auto Hatch", 
    Default = false,
    Callback = function(v)
        config.autoHatch = v
        if v then
            spawn(hatchEgg)
        end
    end 
})

if not config.hatchAnimation then
    config.hatchAnimation = hatchingModule.Play
end

local hatchingAnimationToggle = Tabs.Pets:AddToggle("Hatching Animation Toggle", 
{
    Title = "Hatching Animation", 
    Default = true,
    Callback = function(v)
        config.hatchAnimationState = v
        if v then
            hatchingModule.Play = config.hatchAnimation
        elseif not v and config.hatchingWebhook then
            do end
        else
            hatchingModule.Play = function() return end
        end
    end 
})

task.spawn(function()
    while true do
        if not config.hatchAnimationState and config.hatchingWebhook then
            hatchingAnimationToggle:SetValue(true)
            Fluent:Notify({
                Title = "Hatching Animation",
                Content = "Automatically enabled hatch animation, disabling it will break hatch webhook.",
                Duration = 10
            })
        end
        task.wait()
    end
end)

local enchantingSection = Tabs.Autos:AddSection("Enchanting")

local function updatePets()
    local plrData = localData.Get()

    local equippedPets = {}
    local petInfo = {}
    local formattedInfo = {}

    for i, v in pairs(plrData.Teams) do
        for ii, vv in pairs(v.Pets) do
            table.insert(equippedPets, vv)
        end
    end

    for i, v in pairs(plrData.Pets) do
        if table.find(equippedPets, v.Id) and v.Name then
            local prefix = ""
            if v.MythicShiny then
                prefix = "Mythic Shiny "
            elseif v.Mythic then
                prefix = "Mythic "
            elseif v.Shiny then
                prefix = "Shiny "
            end

            local name = prefix .. v.Name

            if v.Enchants and #v.Enchants > 0 then
                local enchants = {}
                for ii, vv in pairs(v.Enchants) do
                    table.insert(enchants, vv.Id .. "-" .. vv.Level)
                end
                petInfo[v.Id] = {
                    Name = name,
                    Enchants = enchants
                }
            else
                petInfo[v.Id] = {
                    Name = name,
                    Enchants = {}
                }
            end
        end
    end

    for i, v in pairs(petInfo) do
        local enchantStr = "[" .. table.concat(v.Enchants, ", ") .. "]"
        local formattedStr = v.Name .. " " .. enchantStr .. " | " .. i
        table.insert(formattedInfo, formattedStr)
    end

    return formattedInfo
end

local petsMultiDropdown = Tabs.Autos:AddDropdown("Pets MultiDropdown", {
    Title = "Pets",
    Description = "Select the pets to enchant.",
    Values = updatePets(),
    Multi = true,
    Default = {},
})

petsMultiDropdown:OnChanged(function(pet)
    config.selectedEnchantPets = {}
    for petStr, State in next, pet do
        if State then
            local id = string.match(petStr, "|%s*(%S+)$")
            if id then
                table.insert(config.selectedEnchantPets, id)
            end
        end
    end
end)

Tabs.Autos:AddButton({
    Title = "Refresh Pets",
    Callback = function()
        local pets = updatePets()

        if pets then
            petsMultiDropdown:SetValues(pets)
        end
    end
})

local enchantsMultiDropdown = Tabs.Autos:AddDropdown("Enchants MultiDropdown", {
    Title = "Enchants",
    Description = "Select which enchants you want.",
    Values = enchants,
    Multi = true,
    Default = {},
})

enchantsMultiDropdown:OnChanged(function(enchant)
    config.selectedEnchants = {}
    for enchant, State in next, enchant do
        table.insert(config.selectedEnchants, enchant)
    end
end)

local enchantingToggle = Tabs.Autos:AddToggle("Enchanting Toggle", 
{
    Title = "Auto Enchant", 
    Default = false,
    Callback = function(v)
        config.autoEnchant = v
        if v then
            spawn(Enchant)
        end
    end 
})

local purchasingSection = Tabs.Autos:AddSection("Purchasing")

local gumsMultiDropdown = Tabs.Autos:AddDropdown("Gums MultiDropdown", {
    Title = "Gums",
    Description = "Select gums to auto purchase.",
    Values = gumNames,
    Multi = true,
    Default = {},
})

gumsMultiDropdown:OnChanged(function(gum)
    config.selectedGums = {}
    for gum, State in next, gum do
        table.insert(config.selectedGums, gum)
    end
end)

local buyGumsToggle = Tabs.Autos:AddToggle("Auto Buy Gums Toggle", 
{
    Title = "Auto Purchase Gums", 
    Default = false,
    Callback = function(v)
        config.autoBuyGums = v
        if v then
            spawn(buyGums)
        end
    end 
})

local flavorsMultiDropdown = Tabs.Autos:AddDropdown("Flavors MultiDropdown", {
    Title = "Flavors",
    Description = "Select flavors to auto purchase.",
    Values = flavorNames,
    Multi = true,
    Default = {},
})

flavorsMultiDropdown:OnChanged(function(flavor)
    config.selectedFlavors = {}
    for flavor, State in next, flavor do
        table.insert(config.selectedFlavors, flavor)
    end
end)

local buyFlavorsToggle = Tabs.Autos:AddToggle("Auto Buy Flavors Toggle", 
{
    Title = "Auto Purchase Flavors", 
    Default = false,
    Callback = function(v)
        config.autoBuyFlavors = v
        if v then
            spawn(buyFlavors)
        end
    end 
})

local shopsSection = Tabs.Autos:AddSection("Shops")

local shopsMultiDropdown = Tabs.Autos:AddDropdown("Shops MultiDropdown", {
    Title = "Shop Items",
    Description = "Select items to auto purchase.",
    Values = shopsData,
    Multi = true,
    Default = {},
})

shopsMultiDropdown:OnChanged(function(selected)
    if selected["Buy All Items"] then
        config.selectedShopItems = {}
        for _, v in ipairs(shopsData) do
            if v ~= "Buy All Items" then
                table.insert(config.selectedShopItems, v)
            end
        end
    else
        config.selectedShopItems = {}
        for i, v in pairs(selected) do
            if v then
                table.insert(config.selectedShopItems, i)
            end
        end
    end
end)

local buyShopItemsToggle = Tabs.Autos:AddToggle("Buy Shop Items Toggle", 
{
    Title = "Auto Buy Shop Items", 
    Default = false,
    Callback = function(v)
        config.autoBuyShopItems = v
        if v then
            spawn(buyShopItems)
        end
    end 
})

local potionCraftingSection = Tabs.Autos:AddSection("Potion Crafting")

local craftingPotionsMultiDropdown = Tabs.Autos:AddDropdown("Crafting Potions MultiDropdown", {
    Title = "Potions",
    Description = "Select the potions to craft.",
    Values = potionsData,
    Multi = true,
    Default = {},
})

craftingPotionsMultiDropdown:OnChanged(function(potion)
    if potion["Craft All Potions"] then
        config.selectedCraftPotions = {}
        for i,v in pairs(potionsData) do
            table.insert(config.selectedCraftPotions, v)
        end
    else
        config.selectedCraftPotions = {}
        for potion, State in next, potion do
            table.insert(config.selectedCraftPotions, potion)
        end
    end
end)

local craftPotionsToggle = Tabs.Autos:AddToggle("Craft Potions Toggle", 
{
    Title = "Auto Craft Potions", 
    Default = false,
    Callback = function(v)
        config.autoCraftPotions = v
        if v then
            spawn(craftPotions)
        end
    end 
})

local consumePotionSection = Tabs.Autos:AddSection("Auto Use Potion")

local potionsToConsumeMultiDropdown = Tabs.Autos:AddDropdown("Potions To Consume MultiDropdown", {
    Title = "Potions",
    Description = "Select potions to use.",
    Values = potions,
    Multi = true,
    Default = {},
})

potionsToConsumeMultiDropdown:OnChanged(function(potion)
    config.selectedConsumePotions = {}
    for potion, State in next, potion do
        table.insert(config.selectedConsumePotions, potion)
    end
end)

local consumePotionsToggle = Tabs.Autos:AddToggle("Consume Potions Toggle", 
{
    Title = "Auto Use Potions", 
    Default = false,
    Callback = function(v)
        config.autoConsumePotions = v
        if v then
            spawn(consumePotions)
        end
    end 
})

local masterySection = Tabs.Autos:AddSection("Mastery")

local masteryMultiDropdown = Tabs.Autos:AddDropdown("Mastery MultiDropdown", {
    Title = "Masteries",
    Description = "Select the masteries to upgrade.",
    Values = masteries,
    Multi = true,
    Default = {},
})

masteryMultiDropdown:OnChanged(function(mastery)
    config.selectedUpgradeMasteries = {}
    for mastery, State in next, mastery do
        table.insert(config.selectedUpgradeMasteries, mastery)
    end
end)

local masteryToggle = Tabs.Autos:AddToggle("Mastery Toggle", 
{
    Title = "Auto Upgrade Mastery", 
    Default = false,
    Callback = function(v)
        config.autoUpgradeMastery = v
        if v then
            spawn(upgradeMastery)
        end
    end 
})

local othersSection = Tabs.Autos:AddSection("Others")

local playtimeToggle = Tabs.Autos:AddToggle("Playtime Toggle", 
{
    Title = "Claim Playtime Rewards", 
    Default = false,
    Callback = function(v)
        config.autoClaimPlaytime = v
        if v then
            spawn(claimPlaytime)
        end
    end 
})

local doggyJumpToggle = Tabs.Autos:AddToggle("Doggy Jump Toggle", 
{
    Title = "Auto Doggy Jump", 
    Default = false,
    Callback = function(v)
        config.autoDoggyJump = v
        if v then
            spawn(doggyJump)
        end
    end 
})

local claimFreeSpinToggle = Tabs.Autos:AddToggle("Claim Free Spin Toggle", 
{
    Title = "Claim Free Wheel Spin", 
    Default = false,
    Callback = function(v)
        config.autoClaimWheelSpin = v
        if v then
            spawn(claimFreeSpin)
        end
    end 
})

local spinWheelToggle = Tabs.Autos:AddToggle("Spin Wheel Toggle", 
{
    Title = "Auto Spin Wheel", 
    Default = false,
    Callback = function(v)
        config.autoSpinWheel = v
        if v then
            spawn(spinWheel)
        end
    end 
})

local openMysteryBoxToggle = Tabs.Autos:AddToggle("Open Mystery Box Toggle", 
{
    Title = "Auto Claim Mystery Box", 
    Default = false,
    Callback = function(v)
        config.autoOpenMysteryBox = v
        if v then
            spawn(openMysteryBox)
        end
    end 
})

local openChestToggle = Tabs.Autos:AddToggle("Open Chest Toggle", 
{
    Title = "Auto Open Chest", 
    Default = false,
    Callback = function(v)
        config.autoOpenChest = v
        if v then
            spawn(openChest)
        end
    end 
})

local riftsMultiDropdown = Tabs.Rifts:AddDropdown("Rifts MultiDropdown", {
    Title = "Rifts",
    Description = "Select the rifts you want to farm.",
    Values = rifts,
    Multi = true,
    Default = {},
})

local function parseRiftName(riftName)
    local baseName = riftName:split("|")[1]
    return baseName:match("^%s*(.-)%s*$")
end

riftsMultiDropdown:OnChanged(function(rift)
    config.selectedRifts = {}
    for rift, State in next, rift do
        table.insert(config.selectedRifts, parseRiftName(rift))
    end
end)

config.selectedRiftLuck = tonumber(config.selectedRiftLuck)

local riftLuckDropdown = Tabs.Rifts:AddDropdown("Rift Luck Dropdown", {
    Title = "Rift Luck",
    Description = "Determines if it will farm a rift, will target greater than or equal to.",
    Values = {"5", "10", "25"},
    Multi = false,
    Default = "5",
})

riftLuckDropdown:OnChanged(function(riftLuck)
    config.selectedRiftLuck = tonumber(riftLuck)
end)

local riftPotionsMultiDropdown = Tabs.Rifts:AddDropdown("Rift Potions MultiDropdown", {
    Title = "Rift Potions",
    Description = "Potion to use when a x25 luck rift appears.",
    Values = riftPotions,
    Multi = true,
    Default = {},
})

riftPotionsMultiDropdown:OnChanged(function(riftPotion)
    config.selectedRiftPotions = {}
    for riftPotion, State in next, riftPotion do
        table.insert(config.selectedRiftPotions, riftPotion)
    end
end)

local riftWebhookInput = Tabs.Rifts:AddInput("Rifts Webhook Input", {
    Title = "Discord Webhook",
    Description = "For x25 Luck Rifts.",
    Default = "",
    Numeric = false,
    Finished = false,
    Callback = function(webhook)
        config.selectedRiftWebhook = tostring(webhook)
    end
})

local farmRiftToggle = Tabs.Rifts:AddToggle("Farm Rifts Toggle", 
{
    Title = "Auto Rifts", 
    Default = false,
    Callback = function(v)
        config.autoRifts = v
        if v then
            spawn(farmRifts)
        end
    end 
})

local currentQuest = Tabs.Competitive:AddParagraph({
    Title = "Current Quest",
    Content = "..."
})

local questsIgnoreMultiDropdown = Tabs.Competitive:AddDropdown("Ignore Quests MultiDropdown", {
    Title = "Ignore Quests",
    Values = {"Mythic", "Shiny", "Hatch Amount", "Hatch Rarity", "Playtime"},
    Multi = true,
    Default = {},
})

local autoCompToggle

questsIgnoreMultiDropdown:OnChanged(function(quest)
    config.selectedIgnoreQuest = {}
    for quest, State in next, quest do
        table.insert(config.selectedIgnoreQuest, quest)
    end
    if config.autoCompetitive then
        autoCompToggle:SetValue(false)
        autoCompToggle:SetValue(true)
    end
end)

autoCompToggle = Tabs.Competitive:AddToggle("Auto Comp Toggle", 
{
    Title = "Auto Competitive", 
    Default = false,
    Callback = function(v)
        config.autoCompetitive = v
        if v then
            spawn(completeCompQuest)
        else
            currentQuest:SetDesc("Auto Competitive Inactive.")
        end
    end 
})

local hatchingWebhookSection = Tabs.Webhooks:AddSection("Hatching")

local webhookPetRaritiesMultiDropdown = Tabs.Webhooks:AddDropdown("Webhook Pet Rarity MultiDropdown", {
    Title = "Rarities",
    Values = petsRarity,
    Multi = true,
    Default = {},
})

webhookPetRaritiesMultiDropdown:OnChanged(function(petRarity)
    config.selectedWebhookPetRarities = {}
    for petRarity, State in next, petRarity do
        table.insert(config.selectedWebhookPetRarities, petRarity)
    end
end)

local webhookPetsMultiDropdown = Tabs.Webhooks:AddDropdown("Webhook Pets MultiDropdown", {
    Title = "Pets",
    Values = pets,
    Multi = true,
    Default = {},
})

webhookPetsMultiDropdown:OnChanged(function(pet)
    config.selectedWebhookPets = {}
    for pet, State in next, pet do
        table.insert(config.selectedWebhookPets, pet)
    end
end)

local webhookInput = Tabs.Webhooks:AddInput("Webhook Input", {
    Title = "Discord Webhook",
    Default = "",
    Numeric = false,
    Finished = false,
    Callback = function(webhook)
        config.selectedHatchingWebhook = tostring(webhook)
    end
})

local pingEveryoneToggle = Tabs.Webhooks:AddToggle("Ping Everyone Toggle", 
{
    Title = "Ping @everyone", 
    Default = false,
    Callback = function(v)
        config.hatchingWebhookPingAll = v
    end 
})

local function getRandomColor()
    local r = math.random(0, 255)
    local g = math.random(0, 255)
    local b = math.random(0, 255)
    return (r * 0x10000) + (g * 0x100) + b
end

local function sendWebhookMessage(embed, discordWebhook)
    pcall(function()
        local payload = {
            embeds = {embed}
        }

        if config.hatchingWebhookPingAll then
            payload.content = "@everyone"
        end

        http_request({
            Url = discordWebhook,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

local function getImageUrl(assetId)
    local apiUrl = string.format(
        "https://thumbnails.roblox.com/v1/assets?assetIds=%d&size=420x420&format=png",
        assetId
    )

    local response = http_request({
        Url = apiUrl,
        Method = "GET",
        Headers = {
            ["User-Agent"] = "Mozilla/5.0"
        }
    })

    if response and response.Body then
        local data = HttpService:JSONDecode(response.Body)
        if data and data.data and data.data[1] then
            return data.data[1].imageUrl
        end
    end
    return nil
end

local webhookToggle = Tabs.Webhooks:AddToggle("Webhook Toggle", {
    Title = "Hatching Webhook",
    Default = false,
    Callback = function(v)
        config.hatchingWebhook = v
        if v and not getgenv().hatchHook then
            hatchingModule.Play = function(...)
                local args = {...}
                for _, arg in pairs(args) do
                    if typeof(arg) == "table" and arg.Pets then
                        for _, petData in pairs(arg.Pets) do
                            local pet = petData.Pet
                            if pet and pet.Name and pet.Shiny ~= nil then
                                local petName = tostring(pet.Name)
                                local petInfo = petsData[petName]

                                local matchesRarity = petInfo and table.find(config.selectedWebhookPetRarities, petInfo.Rarity)
                                local matchesSpecific = table.find(config.selectedWebhookPets, petName)

                                if matchesRarity or matchesSpecific then
                                    local hatchType
                                    if pet.Mythic and pet.Shiny then
                                        hatchType = "a Mythic Shiny"
                                    elseif pet.Mythic then
                                        hatchType = "a Mythic"
                                    elseif pet.Shiny then
                                        hatchType = "a Shiny"
                                    else
                                        hatchType = "a"
                                    end

                                    local imageId = petInfo and (
                                        pet.Mythic and pet.Shiny and petInfo.MythicShiny or
                                        pet.Mythic and petInfo.Mythic or
                                        pet.Shiny and petInfo.Shiny or
                                        petInfo.Normal
                                    )

                                    local embed = {
                                        title = "BGSI Hatch Alert",
                                        description = lp.Name .. " hatched " .. hatchType .. " " .. petName .. "!",
                                        color = getRandomColor(),
                                        image = {
                                            url = getImageUrl(tonumber(imageId))
                                        },
                                        fields = {
                                            {
                                                name = "Rarity",
                                                value = petInfo and petInfo.Rarity or "Unknown",
                                                inline = true
                                            },
                                            {
                                                name = "Chance",
                                                value = petInfo and petInfo.Chance.."%" or "Unknown",
                                                inline = true
                                            }
                                        },
                                        footer = {
                                            text = "Lunor Hub - " .. os.date("%c")
                                        }
                                    }                                    
                                    sendWebhookMessage(embed, config.selectedHatchingWebhook)
                                end
                            end
                        end
                    end
                end
                return config.hatchAnimation(...)
            end

            getgenv().hatchHook = true

        elseif not v and getgenv().hatchHook then
            hatchingModule.Play = config.hatchAnimation
            getgenv().hatchHook = false
        end
    end
})

Tabs.Misc:AddButton({
    Title = "Unlock All Islands",
    Callback = function()
        unlockAllIslands()
    end
})

Tabs.Misc:AddButton({
    Title = "Claim Codes",
    Callback = function()
        claimAllCodes()
    end
})

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:SetLibrary(Fluent)
SaveManager:SetFolder("ja5on7190/BGSI")
SaveManager:BuildConfigSection(Tabs.Settings)

--Functions

local Noclipping = nil
local Clip = false

local function NoclipLoop()
    if Clip == false and lp.Character ~= nil then
        for _, child in pairs(lp.Character:GetDescendants()) do
            if child:IsA("BasePart") and child.CanCollide == true then
                child.CanCollide = false
            end
        end
    end
end

local tweening = false

function TweenToGoal(targetCFrame, Speed, offset)
    if not offset then
        offset = 20
    end

    if not Speed then
        Speed = lp.Character.Humanoid.WalkSpeed
    end
    tweening = true
    Noclipping = RunService.Stepped:Connect(NoclipLoop)
    local chr = lp.Character or lp.CharacterAdded:Wait()
    local dist = (chr.PrimaryPart.Position - Vector3.new(targetCFrame.X, chr.PrimaryPart.Position.Y, targetCFrame.Z)).Magnitude
    local TweenInfoToUse = TweenInfo.new(dist / Speed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)

    local TweenValue = Instance.new("CFrameValue")
    TweenValue.Value = chr:GetPrimaryPartCFrame()

    TweenValue.Changed:Connect(function()
        local tp = TweenValue.Value
        chr:PivotTo(CFrame.new(tp.X, targetCFrame.Position.Y + offset, tp.Z))
        chr.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
    end)

    getfenv().tween = TweenService:Create(TweenValue, TweenInfoToUse, { Value = targetCFrame })
    getfenv().tween:Play()

    repeat
        task.wait()
    until getfenv().tween.PlaybackState == Enum.PlaybackState.Cancelled or getfenv().tween.PlaybackState == Enum.PlaybackState.Completed

    Noclipping:Disconnect()
    tweening = false
end

local function checkPasses(passName)
    local plrData = localData.Get()

    if plrData and plrData.Passes and plrData.Passes[passName] and plrData.Passes[passName] ~= false then
        return true
    end
    return false
end

function blowBubble()
    while config.autoBlowBubble do
        local plrData = localData.Get()
        local bubbleAmount = plrData.Bubble.Amount
        local bubbleStorage
        if checkPasses("Infinity Gum") then
            bubbleStorage = 1/0
        else
            bubbleStorage = statsUtil.GetBubbleStorage(statsUtil, plrData)
        end
        if bubbleAmount < bubbleStorage then
            Network.FireServer("Event", "BlowBubble")
        end
        task.wait(0.1)
    end
end

local function findBestSellZone()
    local plrData = localData.Get()

    for i,v in pairs(workspace.Worlds["The Overworld"]:GetDescendants()) do
        if v and v.Name == "Sell" and v:IsA("Model") then
            if v.Parent and v.Parent.Name == "The Overworld" then
                return v, "Workspace.Worlds.The Overworld.PortalSpawn"
            elseif v.Parent and v.Parent.Name == "Island" and v.Parent.Parent and v.Parent.Parent:IsA("Folder") and v.Parent.Parent:GetAttribute("Height") and plrData.AreasUnlocked[v.Parent.Parent.Name] then
                return v, "Workspace.Worlds.The Overworld.Islands."..v.Parent.Parent.Name..".Island.Portal.Spawn"
            end
        end
    end
end

local cd = 0.5
local oldCFrame

function sellBubble()
    while config.autoSellBubble do
        local bestSell, bestSellZone = findBestSellZone()
        if config.autoHatch then
            cd = 3
        else
            cd = 0.5
        end
        if bestSell and bestSellZone and lp and lp.Character and lp.Character.PrimaryPart then
            oldCFrame = lp.Character.PrimaryPart.CFrame
            if not tweening then
                if oldCFrame and not ((lp.Character.PrimaryPart.Position - bestSell:GetPivot().Position).Magnitude <= 100) then
                    Network.FireServer("Event", "Teleport", bestSellZone)
                    task.wait(cd)
                    TweenToGoal(CFrame.new(bestSell:GetPivot().Position))
                    for i = 1,5 do
                        Network.FireServer("Event", "SellBubble")
                        task.wait(0.1)
                    end
                    TweenToGoal(oldCFrame)
                else
                    task.wait(cd)
                    TweenToGoal(CFrame.new(bestSell:GetPivot().Position))
                    for i = 1,5 do
                        Network.FireServer("Event", "SellBubble")
                        task.wait(0.1)
                    end
                    TweenToGoal(oldCFrame)
                end
            else
                return
            end
        end
        task.wait(config.sellBubbleCooldown)
    end
end

function findClosestCoin()
    local coin
    local closest = 1/0

    for i,v in pairs(workspace.Rendered:GetDescendants()) do
        if v and v:IsA("MeshPart") and (v.Name:find("Coin") or v.Name:find("coin")) and v.Parent:IsA("Model") and v.Parent.Parent.Name == "Chunker" then
            if lp and lp.Character and lp.Character.PrimaryPart then
                local distance = (lp.Character.PrimaryPart.Position - v.Position).Magnitude
                if distance < closest then
                    closest = distance
                    coin = v.Parent.Name
                end
            end
        end
    end
    return coin
end

function equipBestPet()
    while config.equipBest do
        Network.FireServer("Event", "EquipBestPets")
        task.wait(5)
    end
end

local function isCloseToEgg(eggName)
    for i,v in pairs(workspace.Rendered:GetChildren()) do
        if v.Name == "Chunker" and v:IsA("Folder") then
            if v:FindFirstChild(eggName) then
                local egg = v:FindFirstChild(eggName)
                local distance = (lp.Character.PrimaryPart.Position - egg:GetPivot().Position).Magnitude
                if distance < 15 then
                    return true
                end
            end
        end
    end
    return false
end

function hatchEgg()
    while config.autoHatch do
        if config.selectedHatchEgg == "" then
            hatchingToggle:SetValue(false)
            Fluent:Notify({
                Title = "Missing Egg",
                Content = "Select an Egg...",
                Duration = 10
            })
        end
        if isCloseToEgg(config.selectedHatchEgg) then
            local plrData = localData.Get()
            local hatchAmount = statsUtil.GetMaxEggHatches(statsUtil, plrData)
            Network.FireServer("Event", "HatchEgg", config.selectedHatchEgg, hatchAmount)
        end
        task.wait(0.1)
    end
end

local function getHighestIsland()
    local highestIsland
    local lowest = -1/0

    for i,v in pairs(workspace.Worlds["The Overworld"].Islands:GetChildren()) do
        if v and v:IsA("Folder") and v:GetAttribute("Height") then
            if v:GetAttribute("Height") > lowest then
                lowest = v:GetAttribute("Height")
                highestIsland = v:FindFirstChildOfClass("Model")
            end
        end
    end
    return highestIsland
end

local function parseEnchant(enchantStr)
    local id, level = string.match(enchantStr, "(.+)%-(%d+)$")
    if id and level then
        return {
            Id = id,
            Level = tonumber(level)
        }
    end
    return nil
end

function Enchant()
    while config.autoEnchant do
        local plrData = localData.Get()
        local matchedPetCount = 0

        for _, pet in pairs(plrData.Pets) do
            if table.find(config.selectedEnchantPets, pet.Id) then
                local hasMatch = false

                for _, selectedEnchant in pairs(config.selectedEnchants) do
                    local parsedSelected = parseEnchant(selectedEnchant)

                    if parsedSelected and pet.Enchants then
                        for _, petEnchant in pairs(pet.Enchants) do
                            if petEnchant.Id == parsedSelected.Id and petEnchant.Level == parsedSelected.Level then
                                hasMatch = true
                                break
                            end
                        end
                    end

                    if hasMatch then break end
                end

                if hasMatch then
                    matchedPetCount += 1
                else
                    Network.InvokeServer("Function", "RerollEnchants", pet.Id)
                end
            end
        end

        if matchedPetCount == #config.selectedEnchantPets then
            enchantingToggle:SetValue(false)
            Fluent:Notify({
                Title = "Enchanting Complete!",
                Content = "All selected pets got the selected enchant...",
                Duration = 10
            })
        end
        task.wait(0.1)
    end
end

local function checkOwnedGums(gumName)
    local plrData = localData.Get()
    local ownedGums = plrData.Gum

    for i,v in pairs(ownedGums) do
        if i == gumName and v then
            return true
        end
    end
    return false
end

function buyGums()
    while config.autoBuyGums do
        local plrData = localData.Get()
        local coins = plrData.Coins

        for _,v in pairs(config.selectedGums) do
            if not checkOwnedGums(v) and coins > gums[v].Cost then
                Network.FireServer("Event", "GumShopPurchase", v)
            end
        end
        task.wait(1)
    end
end

local function checkOwnedFlavors(flavorName)
    local plrData = localData.Get()
    local ownedFlavors = plrData.Flavors

    for i,v in pairs(ownedFlavors) do
        if i == flavorName and v then
            return true
        end
    end
    return false
end

function buyFlavors()
    while config.autoBuyFlavors do
        local plrData = localData.Get()
        local coins = plrData.Coins
        local ownedFlavors = plrData.Flavors

        for _,v in pairs(config.selectedFlavors) do
            if not checkOwnedFlavors(v) and coins > flavors[v].Cost then
                Network.FireServer("Event", "GumShopPurchase", v)
            end
        end
        task.wait(1)
    end
end

function parseProductString(formatted)
    local function trim(s)
        return s and s:match("^%s*(.-)%s*$") or nil
    end

    local shopName, name, type, level

    shopName, name, type, level = string.match(
        formatted,
        "^(.-)%s*|%s*(.-)%s*%((%w+)%s*LVL%s*(%d+)%)"
    )

    if not name then
        shopName, name, type = string.match(
            formatted,
            "^(.-)%s*|%s*(.-)%s*%((%w+)%)"
        )
    end

    return {
        ShopName = trim(shopName),
        Name = trim(name),
        Type = trim(type),
        Level = level and tonumber(level) or nil
    }
end

local function shopTrueName(displayName)
    local trueName

    for i,v in pairs(shopsModule) do
        if v.DisplayName == displayName then
            trueName = i
        end
    end
    return trueName
end

function buyShopItems()
    while config.autoBuyShopItems do
        local plrData = localData.Get()

        for _, itemString in pairs(config.selectedShopItems) do
            local itemData = parseProductString(itemString)

            if itemData and itemData.Name and itemData.ShopName then
                local items = shopsUtil.GetItemsData(shopsUtil, shopTrueName(itemData.ShopName), lp, plrData)

                for i, v in pairs(items) do
                    if typeof(v) == "table" and v.Product then
                        local product = v.Product

                        if product.Name == itemData.Name and product.Type == itemData.Type then
                            if product.Level and itemData.Level and product.Level == itemData.Level then
                                Network.FireServer("Event", "BuyShopItem", shopTrueName(itemData.ShopName), i)
                            elseif not product.Level and not itemData.Level then
                                Network.FireServer("Event", "BuyShopItem", shopTrueName(itemData.ShopName), i)
                            end
                        end
                    end
                end
            end
            task.wait(0.1)
        end
        task.wait(3)
    end
end

local function parsePotionString(potionName)
    local name, level = string.match(potionName, "^(.-)%s+(%d+)$")

    if name and level then
        return name:match("^%s*(.-)%s*$"), tonumber(level)
    else
        return potionName, nil
    end
end

function craftPotions()
    while config.autoCraftPotions do
        for i,v in pairs(config.selectedCraftPotions) do
            local name, level = parsePotionString(v)
            Network.FireServer("Event", "CraftPotion", name, level, true)
            task.wait(0.5)
        end
        task.wait(5)
    end
end

local function hasEnoughPotion(potionName, potionLevel)
    local plrData = localData.Get()
    local plrPotions = plrData.Potions

    for i,v in pairs(plrPotions) do
        if v.Name == potionName and v.Level == potionLevel and v.Amount > 0 then
            return true
        end
    end
    return false
end

local function usePotion(name, level)
    local plrData = localData.Get()
    local activePotions = plrData.ActivePotions

    if name and level then
        if activePotions[name] and activePotions[name].Active.Level >= level then
            do end
        else
            if hasEnoughPotion(name, level) then 
                while true do
                    local plrData = localData.Get()
                    local activePotions = plrData.ActivePotions
                    if activePotions[name] and activePotions[name].Active.Level >= level then
                        break
                    else
                        Network.FireServer("Event", "UsePotion", name, level) 
                    end
                    task.wait(0.1)
                end
            end
        end
    end
end

function consumePotions()
    while config.autoConsumePotions do
        for i,v in pairs(config.selectedConsumePotions) do
            local name, level = parsePotionString(v)
            usePotion(name, level)
            task.wait(0.5)
        end
        task.wait(1)
    end
end

function upgradeMastery()
    while config.autoUpgradeMastery do
        for i,v in pairs(config.selectedUpgradeMasteries) do
            Network.FireServer("Event", "UpgradeMastery", v)
            task.wait(0.5)
        end
        task.wait(1)
    end
end

function claimPlaytime()
    while config.autoClaimPlaytime do
        for i = 1,9 do
            Network.InvokeServer("Function", "ClaimPlaytime", i)
            task.wait(0.5)
        end      
        task.wait(3)
    end
end

function doggyJump()
    while config.autoDoggyJump do
        local plrData = localData.Get()
        local len = #doggyJumpUtil.PrizeScores
        local refreshPeriod = doggyJumpUtil.RefreshPeriod

        if plrData.DoggyJump.Claimed < len then
            Network.FireServer("Event", "DoggyJumpWin", 3)
        end

        local waitTime = plrData.DoggyJump.Began + refreshPeriod - timeModule.now()
        if waitTime > 0 then
            task.wait(math.max(1, waitTime) + 1)
        end
        task.wait()
    end
end

function claimFreeSpin()
    while config.autoClaimWheelSpin do
        local plrData = localData.Get()
        local nextSpin = plrData.NextWheelSpin
        local now = os.time()
    
        if not nextSpin or nextSpin <= now then
            Network.FireServer("Event", "ClaimFreeWheelSpin")
            task.wait(1)
        else
            task.wait(nextSpin - now + 1)
        end
        task.wait(10)
    end
end

function spinWheel()
    while config.autoSpinWheel do
        local plrData = localData.Get()
    
        local tickets = plrData.Powerups["Spin Ticket"] or 0
    
        if tickets > 0 then
            Network.InvokeServer("Function", "WheelSpin")
        end
        task.wait(10)
    end
end

function openMysteryBox()
    while config.autoOpenMysteryBox do
        local plrData = localData.Get()
        local amount = plrData.Powerups["Mystery Box"] or 0

        if amount > 0 then
            Network.FireServer("Event", "UseGift", "Mystery Box", amount)
            task.wait(1)
            for _, v in pairs(workspace.Rendered.Gifts:GetChildren()) do
                if v and v:IsA("Part") then
                    Network.FireServer("Event", "ClaimGift", v.Name)
                    --local giftPosition = v.Position
                    --local giftObject = giftModule.new(v, giftPosition)
                    --giftObject:Destroy()
                end
            end
        end
        task.wait(0.5)
    end
end

function openChest()
    while config.autoOpenChest do
        for i,v in pairs(chests) do
            Network.FireServer("Event", "ClaimChest", v, true)
            task.wait(0.1)
        end
        task.wait(5)
    end
end

local function capitalize(str)
    return (str:sub(1,1):upper() .. str:sub(2):lower())
end

local usedChests = {}
local usedPotions = {}
local autoHatchEggName

function farmRifts()
    local currentRift = nil
    local oldCFrame = nil
    local returnedToOld = false
    local isBusy = false
    local wasAutoHatchOn = false
    local turnedToTrue = false
    local savedOldEgg = false

    while config.autoRifts do
        local plrData = localData.Get()
        local matchingRifts = {}
        local chestSelected = false
        local onlyChestsSelected = true
        local royalChest = nil
        local normalChests = {}

        for _, name in ipairs(config.selectedRifts) do
            if name:lower():find("chest") then
                chestSelected = true
            else
                onlyChestsSelected = false
            end
        end

        for _, rift in pairs(workspace.Rendered.Rifts:GetChildren()) do
            if table.find(config.selectedRifts, rift.Name) then
                local isChest = rift.Name:lower():find("chest")
                if rift.Name:lower() == "royal-chest" then
                    local chestKey = "Royal Key"
                    if plrData.Powerups[chestKey] and plrData.Powerups[chestKey] > 0 and not usedChests[rift.Name] then
                        royalChest = rift
                    end
                elseif isChest then
                    table.insert(normalChests, rift)
                else
                    local display = rift:FindFirstChild("Display")
                    if display then
                        local sGui = display:FindFirstChild("SurfaceGui")
                        if sGui then
                            local icon = sGui:FindFirstChild("Icon")
                            if icon then
                                local luck = icon:FindFirstChild("Luck")
                                if luck and luck:IsA("TextLabel") then
                                    local luck = luck.Text:gsub("x", "")
                                    local luckValue = tonumber(luck)
                                    if luckValue and luckValue >= config.selectedRiftLuck then
                                        table.insert(matchingRifts, rift)
                                    end
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.1)
        end

        if royalChest and not isBusy then
            isBusy = true
            currentRift = nil

            if not oldCFrame then
                oldCFrame = lp.Character.PrimaryPart.CFrame
            end

            local chestPos = royalChest:GetPivot().Position
            if (lp.Character.PrimaryPart.Position - chestPos).Magnitude > 10 then
                TweenToGoal(CFrame.new(chestPos))
            end

            local success = true

            while true do
                local plrData = localData.Get()
                local chestKey = "Royal Key"
                local amount = plrData.Powerups[chestKey] or 0
            
                if amount <= 0 or not royalChest or not royalChest:IsDescendantOf(workspace) or not config.autoRifts then
                    success = false
                    break
                else
                    Network.FireServer("Event", "UnlockRiftChest", royalChest.Name, false)
                end
                task.wait(0.1)
            end            

            if success then
                usedChests[royalChest.Name] = true
            end

            TweenToGoal(oldCFrame)
            returnedToOld = false
            isBusy = false

        elseif not isBusy then
            if #matchingRifts > 0 then
                local bestRift = nil
                
                local manEggRifts = {}
                local nonManRifts = {}

                for _, rift in ipairs(matchingRifts) do
                    local display = rift:FindFirstChild("Display")
                    if display then
                        local sGui = display:FindFirstChild("SurfaceGui")
                        local icon = sGui and sGui:FindFirstChild("Icon")
                        local timer = sGui and sGui:FindFirstChild("Timer")

                        if icon and timer then
                            local luckLabel = icon:FindFirstChild("Luck")
                            if luckLabel and luckLabel:IsA("TextLabel") then
                                local luckText = luckLabel.Text:gsub("x", "")
                                local luckValue = tonumber(luckText)

                                if luckValue then
                                    if luckValue >= 25 and not usedPotions[rift] then
                                        for _, potion in pairs(config.selectedRiftPotions) do
                                            local name, level = parsePotionString(potion)
                                            usePotion(name, level)
                                            task.wait(0.5)
                                        end
                                        local embed = {
                                            title = "BGSI Rift Alert",
                                            description = "A x25 Luck "..rift.Name.." has spawned, despawns in "..timer.Text..".",
                                            color = getRandomColor(),
                                            footer = { text = "Lunor Hub - " .. os.date("%c") }
                                        }
                                        sendWebhookMessage(embed, config.selectedRiftWebhook)
                                        usedPotions[rift] = true
                                    end

                                    if rift.Name:lower():find("man") then
                                        table.insert(manEggRifts, {rift = rift, luck = luckValue})
                                    else
                                        table.insert(nonManRifts, {rift = rift, luck = luckValue})
                                    end
                                end
                            end
                        end
                    end
                end

                local function getBestByLuck(riftList)
                    local best = nil
                    local maxLuck = -math.huge
                    for _, data in ipairs(riftList) do
                        if data.luck > maxLuck then
                            best = data.rift
                            maxLuck = data.luck
                        end
                    end
                    return best
                end

                if #manEggRifts > 0 then
                    bestRift = getBestByLuck(manEggRifts)
                else
                    bestRift = getBestByLuck(nonManRifts)
                end                

                if bestRift then
                    currentRift = bestRift
                end

                if currentRift then
                    if not oldCFrame then
                        oldCFrame = lp.Character.PrimaryPart.CFrame
                    end

                    local targetPos = currentRift:GetPivot().Position
                    if (lp.Character.PrimaryPart.Position - targetPos).Magnitude > 10 and not tweening then
                        TweenToGoal(CFrame.new(targetPos))
                    end

                    local hatchAmount = statsUtil.GetMaxEggHatches(statsUtil, plrData)
                    if config.autoHatch and not savedOldEgg then
                        autoHatchEggName = config.selectedHatchEgg
                        eggsDropdown:SetValue(riftName[currentRift.Name])
                        wasAutoHatchOn = true
                        savedOldEgg = true
                    elseif not config.autoHatch then
                        eggsDropdown:SetValue(riftName[currentRift.Name])
                        hatchingToggle:SetValue(true)
                        turnedToTrue = true
                    end
                end
            elseif #normalChests > 0 and chestSelected then
                for _, rift in ipairs(normalChests) do
                    local chestType = rift.Name:gsub("-chest", "")
                    local chestKey = capitalize(chestType) .. " Key"
                    local amount = plrData.Powerups[chestKey] or 0

                    if amount > 0 and not usedChests[rift.Name] then
                        isBusy = true
                        if not oldCFrame then
                            oldCFrame = lp.Character.PrimaryPart.CFrame
                        end

                        local chestPos = rift:GetPivot().Position
                        if (lp.Character.PrimaryPart.Position - chestPos).Magnitude > 10 then
                            TweenToGoal(CFrame.new(chestPos))
                        end

                        local success = true

                        while true do
                            local plrData = localData.Get()
                            local amount = plrData.Powerups[chestKey] or 0
                        
                            if amount <= 0 or not rift or not rift:IsDescendantOf(workspace) or not config.autoRifts then
                                success = false
                                break
                            else
                                Network.FireServer("Event", "UnlockRiftChest", rift.Name, false)
                            end
                            task.wait(0.1)
                        end   

                        if success then
                            usedChests[rift.Name] = true
                        end

                        TweenToGoal(oldCFrame)
                        returnedToOld = false
                        isBusy = false
                        break
                    end
                    task.wait(0.1)
                end
            elseif oldCFrame and not returnedToOld and not tweening then
                if wasAutoHatchOn and not turnedToTrue and savedOldEgg then
                    eggsDropdown:SetValue(autoHatchEggName)
                    savedOldEgg = false
                    wasAutoHatchOn = false
                elseif turnedToTrue then
                    config.selectedHatchEgg = ""
                    hatchingToggle:SetValue(false)
                    turnedToTrue = false
                end
                TweenToGoal(oldCFrame)
                returnedToOld = true
            end                     
        end
        task.wait(0.1)
    end
end    

local lastHatches
local lastTotalKey
local lastChangeTime = tick()

task.spawn(function()
    while true do
        if config.autoHatch and config.autoRifts then
            local plrData = localData.Get()
            local hatches = plrData.Stats.Hatches
            local rKey = plrData.Powerups["Royal Key"]
            local gKey = plrData.Powerups["Golden Key"]
            local totalKey = rKey + gKey

            if lastHatches == nil or lastTotalKey == nil then
                lastHatches = hatches
                lastTotalKey = totalKey
                lastChangeTime = tick()
            end

            if hatches ~= lastHatches or totalKey < lastTotalKey then
                lastChangeTime = tick()
                lastHatches = hatches
                lastTotalKey = totalKey
            end

            if tick() - lastChangeTime >= 60 then
                for i, v in pairs(getnilinstances()) do
                    if v:IsA("Model") and v.Name == config.selectedHatchEgg then
                        TweenToGoal(CFrame.new(v:GetPivot().Position))
                        break
                    end
                end
                eggsDropdown:SetValue(autoHatchEggName)
                hatchingToggle:SetValue(false)
                task.wait(0.1)
                hatchingToggle:SetValue(true)
                task.wait(0.1)
                farmRiftToggle:SetValue(false)
                task.wait(0.1)
                farmRiftToggle:SetValue(true)
                lastChangeTime = tick()
            end
        end
        task.wait(0.1)
    end
end)

local blacklistedEggs = {"Aura Egg", "Season 1 Egg", "Series 1 Egg", "Silly Egg", "100M Egg", "Throwback Egg"}

local function findEasiestPetEgg(rarity)
    local easiestEgg
    local highest = -1/0

    for i,v in pairs(petsModule) do
        if v.Rarity == rarity and v.Chance and v.Egg and not table.find(blacklistedEggs, v.Egg) then
            if v.Chance > highest then
                highest = v.Chance
                easiestEgg = v.Egg
            end
        end
    end
    return easiestEgg
end

local function findEgg(eggName)
    local egg
    local closest = 1/0

    if eggName ~= "Common Egg" then
        for i,v in pairs(workspace.Rendered.Generic:GetChildren()) do
            if v:IsA("Model") and v.Name == eggName then
                local distance = (lp.Character.PrimaryPart.Position - v:GetPivot().Position).Magnitude
                if distance < closest then
                    closest = distance
                    egg = v:GetPivot().Position
                end
            end
        end
    else
        for i,v in pairs(workspace.Rendered.Generic:GetChildren()) do
            if v:IsA("Model") and v.Name == "Common Egg" then
                local distance = (Vector3.new(-11.895793, 9.33136845, -93.9566879) - v:GetPivot().Position).Magnitude
                if distance < closest then
                    closest = distance
                    egg = v:GetPivot().Position
                end
            end
        end
    end
    return egg
end

local teleported = false
local lastRerolledQuest = {}
local rerollCooldown = 1

local function countTableKeys(t)
    local count = 0
    for _ in pairs(t) do
        count += 1
    end
    return count
end

function getQuestType(questTask)
    if questTask.Type == "Hatch" and questTask.Egg and questTask.Egg ~= nil and questTask.Amount then
        return "Hatch Egg"
    elseif questTask.Type == "Hatch" and questTask.Amount and not questTask.Egg and countTableKeys(questTask) == 2 then
        return "Hatch Amount"
    elseif questTask.Type == "Hatch" and questTask.Mythic then
        return "Hatch Mythic"
    elseif questTask.Type == "Hatch" and questTask.Rarity then
        return "Hatch Rarity"
    elseif questTask.Type == "Hatch" and questTask.Shiny then
        return "Hatch Shiny"
    elseif questTask.Type == "Playtime" then
        return "Playtime"
    end
end

function handleCompetitiveQuest(quest, questTask, progress, hatchAmount)
    local plrData = localData.Get()

    local function teleportToEgg(egg)
        if lp and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local island = eggsData[egg] and eggsData[egg].Island
            local destination = island and island ~= "The Overworld"
                and "Workspace.Worlds.The Overworld.Islands." .. island .. ".Island.Portal.Spawn"
                or "Workspace.Worlds.The Overworld.PortalSpawn"

            if not teleported then
                local startTime = os.clock()
                while os.clock() - startTime < 1 do
                    Network.FireServer("Event", "Teleport", destination)
                    task.wait(0.05)
                end
                teleported = true
                task.wait(0.5)
            end

            local eggPos = findEgg(egg)
            if eggPos and (lp.Character.PrimaryPart.Position - eggPos).Magnitude > 15 then
                TweenToGoal(CFrame.new(eggPos), nil, 5)
            end
        end
    end

    local questType = getQuestType(questTask)

    if questType == "Hatch Egg" then
        teleportToEgg(questTask.Egg)
        Network.FireServer("Event", "HatchEgg", questTask.Egg, hatchAmount)
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " " .. questTask.Egg .. "\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Shiny" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Shinies\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Mythic" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Mythics\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Playtime" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        local desc = "Current Quest: Playtime " .. questTask.Amount .. "\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Amount" then
        local defaultEgg = findEasiestPetEgg("Legendary")
        teleportToEgg(defaultEgg)
        Network.FireServer("Event", "HatchEgg", defaultEgg, hatchAmount)
        local desc = "Current Quest: Hatch " .. questTask.Amount .. " Eggs\nProgress: " .. progress .. "/" .. questTask.Amount
        task.spawn(function()
            currentQuest:SetDesc(desc)
        end)
        task.wait(0.1)
        return true

    elseif questType == "Hatch Rarity" then
        local easiestEgg = findEasiestPetEgg(questTask.Rarity)
        if easiestEgg then
            teleportToEgg(easiestEgg)
            Network.FireServer("Event", "HatchEgg", easiestEgg, hatchAmount)
            local desc = "Current Quest: Hatch " .. questTask.Amount .. " " .. questTask.Rarity .. "\nProgress: " .. progress .. "/" .. questTask.Amount
            task.spawn(function()
                currentQuest:SetDesc(desc)
            end)
            task.wait(0.1)
            return true
        end
    end
    return false
end

previousIgnoreTable = {}

function saveIgnoreTable()
    previousIgnoreTable = table.clone(config.selectedIgnoreQuest)
end

function restoreIgnoreTable()
    config.selectedIgnoreQuest = previousIgnoreTable
end

function completeCompQuest()
    teleported = false
    while config.autoCompetitive do
        local plrData = localData.Get()
        local hatchAmount = statsUtil:GetMaxEggHatches(plrData)
        local comp3 = questsUtil:FindById(plrData, "competitive-3")
        local comp4 = questsUtil:FindById(plrData, "competitive-4")
        local didHandle = false

        local function isQuestIgnored(q)
            if not q then return true end
            local task = q.Tasks[1]
            if task.Type == "Hatch" and task.Shiny then return table.find(config.selectedIgnoreQuest, "Shiny") end
            if task.Type == "Hatch" and task.Mythic then return table.find(config.selectedIgnoreQuest, "Mythic") end
            if task.Type == "Playtime" then return table.find(config.selectedIgnoreQuest, "Playtime") end
            if task.Type == "Hatch" and task.Rarity then return table.find(config.selectedIgnoreQuest, "Hatch Rarity") end
            if task.Type == "Hatch" and task.Amount and not task.Egg and countTableKeys(task) == 2 then return task.Amount > 1000 and table.find(config.selectedIgnoreQuest, "Hatch Amount") end            
            return false
        end

        local comp3Ignored = isQuestIgnored(comp3)
        local comp4Ignored = isQuestIgnored(comp4)

        if not comp3Ignored then
            didHandle = handleCompetitiveQuest(comp3, comp3.Tasks[1], comp3.Progress[1], hatchAmount)
        end
        if not didHandle and not comp4Ignored then
            didHandle = handleCompetitiveQuest(comp4, comp4.Tasks[1], comp4.Progress[1], hatchAmount)
        end

        if not didHandle then
            local rrOrb = plrData.Powerups["Reroll Orb"]

            if comp3Ignored and comp4Ignored then
                if not rrOrb or rrOrb <= 5 then
                    saveIgnoreTable()
                    config.selectedIgnoreQuest = {}
                else
                    if comp3 then
                        local questId = comp3.Id:gsub("competitive--", "")
                        questId = tonumber(questId)
                        Network.FireServer("Event", "CompetitiveReroll", questId)
                    end
                    if comp4 then
                        local questId = comp4.Id:gsub("competitive--", "")
                        questId = tonumber(questId)
                        Network.FireServer("Event", "CompetitiveReroll", questId)
                    end
                end
            end
            teleported = false
        end
        task.wait()
    end
end

task.spawn(function()
    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local currentRerollCount = plrData.Powerups["Reroll Orb"]

            if currentRerollCount and currentRerollCount > 5 and #config.selectedIgnoreQuest == 0 then
                restoreIgnoreTable()
            end
        end
        task.wait(1)
    end
end)

task.spawn(function()
    local lastComp3Progress = 0
    local lastComp4Progress = 0
    local wasNonZero3 = false
    local wasNonZero4 = false
    
    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local comp3 = questsUtil:FindById(plrData, "competitive-3")
            local comp4 = questsUtil:FindById(plrData, "competitive-4")
            
            if comp3.Progress[1] >= comp3.Tasks[1].Amount then
                lastCompleted = "comp3"
                teleported = false
            end
            
            if comp4.Progress[1] >= comp4.Tasks[1].Amount then
                lastCompleted = "comp4"
                teleported = false
            end
            
            if comp3.Progress[1] > 0 then
                wasNonZero3 = true
                lastComp3Progress = comp3.Progress[1]
            elseif wasNonZero3 and comp3.Progress[1] == 0 and lastComp3Progress > 0 then
                lastCompleted = "comp3"
                wasNonZero3 = false
                teleported = false
            end
            
            if comp4.Progress[1] > 0 then
                wasNonZero4 = true
                lastComp4Progress = comp4.Progress[1]
            elseif wasNonZero4 and comp4.Progress[1] == 0 and lastComp4Progress > 0 then
                lastCompleted = "comp4"
                wasNonZero4 = false
                teleported = false
            end
        end
        task.wait()
    end
end)

local old
getgenv().shouldReToggle = false

old = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
    local args = {...}
    local ncm = getnamecallmethod()

    if tostring(Self.Name) == "Event" and ncm == "FireServer" and args[1] == "CompetitiveReroll" then
        if config.autoCompetitive then
            getgenv().shouldReToggle = true
        end
    end
    return old(Self, ...)
end))

task.spawn(function()
    while true do
        if config.autoCompetitive then
            if getgenv().shouldReToggle then
                autoCompToggle:SetValue(false)
                task.wait(0.5)
                autoCompToggle:SetValue(true)
                getgenv().shouldReToggle = false
            end
        end
        task.wait(0.1)
    end
end)

task.spawn(function()
    local plrData = localData.Get()
    local lastHatchCount = plrData.Stats.Hatches
    local lastChangeTime = os.clock()

    while true do
        if config.autoCompetitive then
            local plrData = localData.Get()
            local currentHatchCount = plrData.Stats.Hatches

            if currentHatchCount ~= lastHatchCount then
                lastHatchCount = currentHatchCount
                lastChangeTime = os.clock()
            elseif os.clock() - lastChangeTime >= 10 then
                autoCompToggle:SetValue(false)
                task.wait(0.5)
                autoCompToggle:SetValue(true)
                lastChangeTime = os.clock()
            end
        end
        task.wait(0.1)
    end
end)

task.spawn(function()
    while task.wait(0.5) do
        local found = false

        for _, v in pairs(CoreGui:GetChildren()) do
            if v:IsA("ScreenGui") and v:GetAttribute("Animations") then
                found = true
                break
            end
        end

        if not found then
            config.hatchingWebhook = false
            hatchingModule.Play = config.hatchAnimation
            getgenv().hatchHook = false
            break
        else
            do end
        end
    end
end)

function unlockAllIslands()
    local plrData = localData.Get()
    if plrData.AreasUnlocked[getHighestIsland().Parent.Name] then
        Fluent:Notify({
            Title = "Status",
            Content = "You've already unlocked all islands...",
            Duration = 10
        })
        return
    end
    local highestIsland = getHighestIsland():GetPivot().Position

    if highestIsland then
        Network.FireServer("Event", "Teleport", "Workspace.Worlds.The Overworld.PortalSpawn")
        task.wait(1.2)
        if lp and lp.Character and lp.Character.PrimaryPart then
            local dist = (lp.Character.PrimaryPart.Position - highestIsland).Magnitude
            local dest = CFrame.new(highestIsland)
            local TweenInfoToUse = TweenInfo.new(dist / 5000, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)

            local TweenValue = Instance.new("CFrameValue")
            TweenValue.Value = lp.Character:GetPrimaryPartCFrame()

            TweenValue.Changed:Connect(function()
                lp.Character:PivotTo(TweenValue.Value)
                lp.Character.PrimaryPart.Velocity = Vector3.new(0, 0, 0)
            end)
    
            local OnTween = TweenService:Create(TweenValue, TweenInfoToUse, { Value = dest })
            OnTween:Play()
            OnTween.Completed:Wait()
        end
    end
end

function claimAllCodes()
    for i,v in pairs(codes) do
        Network.InvokeServer("Function", "RedeemCode", v)
        task.wait(0.1)
    end
end

SaveManager:LoadAutoloadConfig()
